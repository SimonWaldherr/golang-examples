var sqlqueries = {"01-beginner - HelloWorld":"package main\n\nfunc main() {\n\t\/\/ print string\n\tprint(\"Hello World\\n\")\n}\n","01-beginner - HelloWorld2":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\n\/\/ in go you can write comments after \"\/\/\"\n\n\/*\nto write multiline comments you can write\ninside of \"\/ *\" and \"* \/\" (without the spaces\n*\/\n\nfunc main() {\n\t\/\/ declare a variable\n\tvar str = \"Hello World\"\n\n\t\/\/ print variable\n\tfmt.Println(str)\n}\n","01-beginner - HelloWorldShebang":"\/\/usr\/bin\/env go run $0 $@ ; exit\n\npackage main\n\nfunc main() {\n\t\/\/ print string\n\tprint(\"Hello World\\n\")\n}\n","01-beginner - RoundRobinSchedulingAlgorithm":"package main\n\nimport \"fmt\"\n\n\/**\n * Thanks https:\/\/en.wikipedia.org\/wiki\/Round-robin_tournament#Scheduling_algorithm\n *\n * @param int weeks\n * @param array teams\n * @return array\n *\/\n\/\/ added return type to the end\nfunc schedule(weeks int, teams []int) [][][]int {\n\n\t\/\/Check if team count is odd, if so we add a 'bye'\n\tif len(teams)%2 != 0 {\n\t\tteams = append(teams, len(teams)+1)\n\t}\n\n\thalfTeams := len(teams) \/ 2\n\n\tmTeams := teams[1:]\n\tcount := len(mTeams)\n\n\tsched := make([][][]int, weeks)\n\n\tfor i := 0; i < weeks; i++ {\n\t\tteamIndex := i % count\n\n\t\tsched[i] = make([][]int, halfTeams)\n\n\t\tsched[i][0] = make([]int, 2)\n\n\t\tsched[i][0][0] = teams[0]\n\t\tsched[i][0][1] = mTeams[teamIndex]\n\n\t\tfor j := 1; j < halfTeams; j++ {\n\t\t\tteamA := (i + j) % count\n\t\t\tteamB := (i + count - j) % count\n\n\t\t\tsched[i][j] = make([]int, 2)\n\n\t\t\tsched[i][j][0] = mTeams[teamA]\n\t\t\tsched[i][j][1] = mTeams[teamB]\n\t\t}\n\t}\n\n\treturn sched\n}\n\nfunc main() {\n\tweeks := 13\n\tteams := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\n\n\tfmt.Println(schedule(weeks, teams))\n}\n","01-beginner - ackermann":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc ack(n, m int64) int64 {\n\tfor n != 0 {\n\t\tif m == 0 {\n\t\t\tm = 1\n\t\t} else {\n\t\t\tm = ack(n, m-1)\n\t\t}\n\t\tn = n - 1\n\t}\n\treturn m + 1\n}\n\nfunc main() {\n\tif len(os.Args) > 2 {\n\t\tia1, _ := strconv.ParseInt(os.Args[1], 10, 0)\n\t\tia2, _ := strconv.ParseInt(os.Args[2], 10, 0)\n\t\tfmt.Println(ack(ia1, ia2))\n\t}\n}\n","01-beginner - args":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n\/\/ main function\nfunc main() {\n\n\t\/\/ print each argument\n\tfor i := 1; i < len(os.Args); i++ {\n\t\tfmt.Println(os.Args[i])\n\t}\n}\n","01-beginner - array":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\n\/\/ declare variables and define array content\nvar strarray = []string{\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\"}\nvar intarray = []int{1, 2, 4, 8, 16}\nvar mapone = map[int]string{}\nvar maptwo = map[string]interface{}{}\n\nfunc main() {\n\n\t\/\/ do this five times\n\tfor i := 0; i != 5; i++ {\n\n\t\t\/\/ print the $th value of the intarray and the strarray\n\t\tfmt.Println(intarray[i], \"\\t\", strarray[i])\n\n\t\tmapone[intarray[i]] = strarray[i]\n\t\tmaptwo[strarray[i]] = mapone\n\t}\n\tfmt.Println(mapone)\n\tfmt.Println(maptwo)\n}\n","01-beginner - cat":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tvar buffer bytes.Buffer\n\tfor i := 0; i < 32; i++ {\n\t\tbuffer.WriteString(\"a\")\n\t}\n\ts := buffer.String()\n\tfor i := 0; i < 8192; i++ {\n\t\ts += strconv.Itoa(i)\n\t}\n\ts += buffer.String()\n\tfor i := 0; i < 512; i++ {\n\t\ts = \"pre\" + s\n\t}\n\tfmt.Println(s)\n}\n","01-beginner - constants":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\t\/\/simple constants\n\tconst stringConstant = \"string\"\n\tconst boolConstant = true\n\tconst intConstant = 1234\n\n\tfmt.Print(stringConstant)\n\tfmt.Print(boolConstant)\n\tfmt.Print(intConstant)\n\n\t\/\/simple constant with type\n\tconst float64Constant float64 = 1234.00\n\n\tfmt.Print(float64Constant)\n\n\t\/\/multiple constants\n\tconst color, code = \"red\", 255\n\n\tfmt.Print(color)\n\tfmt.Print(code)\n\n\tconst (\n\t\tcompany string  = \"Go Experts\"\n\t\tsalary  float64 = 50000.0\n\t)\n\n\tfmt.Print(company)\n\tfmt.Print(salary)\n}\n","01-beginner - deleteFromSlice":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tmySlice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\t\/\/ Deleting from a slice is basically appending the entire slice to itself, but excluding the deleted item\n\tmySlice = append(mySlice[:4], mySlice[5:]...)\n\tfmt.Println(mySlice)\n}\n","01-beginner - dir":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tdir, _ := os.Getwd()\n\tfmt.Println(strings.Replace(dir, \" \", \"\\\\ \", -1))\n}\n","01-beginner - draw_cuboid":"package main\n \nimport \"fmt\"\n \nfunc cuboidDraw(drawX, drawY, drawZ int) {\n    fmt.Printf(\"Cuboid %d %d %d:\\n\", drawX, drawY, drawZ)\n    cubeLine(drawY+1, drawX, 0, \"+-\")\n    for i := 1; i <= drawY; i++ {\n        cubeLine(drawY-i+1, drawX, i-1, \"\/ |\")\n    }\n\tcubeLine(0, drawX, drawY, \"+-|\")\n    for i := 4*drawZ - drawY - 2; i > 0; i-- {\n        cubeLine(0, drawX, drawY, \"| |\")\n    }\n    cubeLine(0, drawX, drawY, \"| +\")\n    for i := 1; i <= drawY; i++ {\n        cubeLine(0, drawX, drawY-i, \"| \/\")\n    }\n    cubeLine(0, drawX, 0, \"+-\\n\")\n}\n \nfunc cubeLine(n, drawX, drawY int, cubeDraw string) {\n    fmt.Printf(\"%*s\", n+1, cubeDraw[:1])\n    for d := 9*drawX - 1; d > 0; d-- {\n        fmt.Print(cubeDraw[1:2])\n    }\n    fmt.Print(cubeDraw[:1])\t\t\n    fmt.Printf(\"%*s\\n\", drawY+1, cubeDraw[2:])\n}\n \nfunc main() {\n\tfmt.Println(\"Enter 3 dimensions of Cuboid : \")\n    var l,b,h int\n    fmt.Scanln(&l)\n\tfmt.Scanln(&b)\n\tfmt.Scanln(&h)\n\tcuboidDraw(l,b,h)\n}\n","01-beginner - environment_var":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tos.Setenv(\"FOO\", \"1\")\n\tfmt.Println(\"FOO:\", os.Getenv(\"FOO\"))\n\tfmt.Println(\"BAR:\", os.Getenv(\"BAR\"))\n\n\tfmt.Println()\n\tfor _, e := range os.Environ() {\n\t\tpair := strings.Split(e, \"=\")\n\t\tfmt.Println(pair[0])\n\t}\n}\n","01-beginner - euklid":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc euklid(a, b int64) int64 {\n\tfor b != 0 {\n\t\ta, b = b, a%b\n\t}\n\treturn a\n}\n\nfunc main() {\n\tif len(os.Args) > 2 {\n\t\tia1, _ := strconv.ParseInt(os.Args[1], 10, 0)\n\t\tia2, _ := strconv.ParseInt(os.Args[2], 10, 0)\n\t\tfmt.Println(euklid(ia1, ia2))\n\t}\n}\n","01-beginner - factorial":"package main\n\nimport \"fmt\"\n\nfunc factorial(num int) int {\n\tif num == 1 || num == 0 {\n\t\treturn num\n\t}\n\treturn num * factorial(num-1)\n}\nfunc main() {\n\tfmt.Println(factorial(3))\n}\n","01-beginner - fibonacci":"package main\n\nimport \"fmt\"\n\nfunc fibonacci() func() int {\n\ta, b := 0, 1\n\treturn func() int {\n\t\tret := a\n\t\ta, b = b, a+b\n\t\treturn ret\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n","01-beginner - file":"package main\n\nimport \"os\"\n\n\/\/ OpenCreateFile open an existed file or create a file if not exists\nfunc OpenCreateFile(path string) *os.File {\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\tf, err := os.Create(path)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn f\n\t}\n\t\/\/ open file in read-write mode\n\tf, err := os.OpenFile(path, os.O_RDWR, 0644)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn f\n}\n\nfunc main() {\n\tfp := OpenCreateFile(\"test.txt\")\n\tfp.WriteString(\"Hello World\")\n\tfp.Close()\n}\n","01-beginner - file_temp":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\t\/\/ Create a temporary file\n\tf, err := os.CreateTemp(\"\", \"sample\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t\/\/ Display the name of the just created temporary file\n\tfmt.Println(\"Temp file name:\", f.Name())\n\n\t\/\/ Clean up the file after we're done\n\tdefer os.Remove(f.Name())\n\n\t\/\/ Write some data to the file\n\t_, err = f.Write([]byte(\"Hello\\nWorld\\n\"))\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n}\n","01-beginner - fileserver":"package main\n\nimport (\n\t\"net\/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"\/\", http.FileServer(http.Dir(\".\/\")))\n\thttp.ListenAndServe(\":8080\", nil)\n}\n","01-beginner - fizzbuzz":"\/\/ Fizzbuzz is a common programming test.\n\/\/ The objective is to print the integers 1 to 100, but:\n\/\/ \t\t-for multiples of 3, print fizz instead of the number\n\/\/ \t\t-for multiples of 5, print buzz instead of the number\n\/\/ \t\t-for multiples of 3 and 5, print fizzbuzz instead of the number\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfor index := 1; index < 100; index++ {\n\t\tswitch {\n\t\tcase index%15 == 0:\n\t\t\tfmt.Println(\"fizzbuzz\")\n\t\tcase index%3 == 0:\n\t\t\tfmt.Println(\"fizz\")\n\t\tcase index%5 == 0:\n\t\t\tfmt.Println(\"buzz\")\n\t\tdefault:\n\t\t\tfmt.Println(index)\n\t\t}\n\t}\n}\n","01-beginner - flag":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar arg1 int\n\tvar arg2 string\n\tvar arg3 float64\n\tflag.IntVar(&arg1, \"a\", 0, \"first argument (int)\")\n\tflag.StringVar(&arg2, \"b\", \"lorem\", \"second argument (string)\")\n\tflag.Float64Var(&arg3, \"c\", 13.37, \"third argument (float)\")\n\tflag.Parse()\n\tfmt.Printf(\"flag input was: \\n\\targ1: %v\\n\\targ2: %v\\n\\targ3: %v\\n\\n\", arg1, arg2, arg3)\n}\n","01-beginner - for":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(i)\n\t}\n}\n","01-beginner - foreach":"package main\n\nimport (\n\t\"fmt\"\n)\n\n\/\/ declare variables and define array content\nvar strarray = []string{\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\"}\n\nfunc main() {\n\tfor index, data := range strarray {\n\t\tfmt.Println(index, data)\n\t}\n}\n","01-beginner - function":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\n\/\/ a function which add up two integers and returns it as int\nfunc plus(a int, b int) int {\n\treturn a + b\n}\n\n\/\/ a function which subtract an integer from an integer and returns it as int\nfunc minus(a int, b int) int {\n\treturn a - b\n}\n\n\/\/ main function\nfunc main() {\n\tfmt.Println(plus(3, minus(10, 5)))\n}\n","01-beginner - functionvariadic":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvariadic(1, 2, 3, 4, 5)\n}\n\n\/\/ Variadic functions can have zero or n parameters passed\n\/\/ The arguments passed to a variadic function are appended to a slice of the same type\nfunc variadic(numbers ...int) {\n\tfmt.Printf(\"Type: %T\\t Content: %d\\n\", numbers, numbers)\n}\n","01-beginner - generatecsv":"package main\n\nimport (\n\t\"encoding\/csv\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\trows := [][]string{\n\t\t{\"Language\", \"Version\", \"Date\"},\n\t\t{\"Java\", \"1.19\", \"2022-08-02\"},\n\t\t{\"Go\", \"Paris\", \"2022-09-22\"},\n\t}\n\n\tcsvfile, err := os.Create(\"languages.csv\")\n\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to create file: %s\", err)\n\t}\n\n\tcsvwriter := csv.NewWriter(csvfile)\n\n\tfor _, row := range rows {\n\t\t_ = csvwriter.Write(row)\n\t}\n\n\tcsvwriter.Flush()\n\n\tcsvfile.Close()\n}\n","01-beginner - hashing":"package main\n\nimport (\n\t\"crypto\/hmac\"\n\t\"crypto\/md5\"\n\t\"crypto\/sha256\"\n\t\"crypto\/sha512\"\n\t\"encoding\/base64\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc main() {\n\tinput := \"Lorem Ipsum dolor sit Amet\"\n\tmd5 := md5.New()\n\tsha_256 := sha256.New()\n\tsha_512 := sha512.New()\n\tio.WriteString(md5, input)\n\tsha_256.Write([]byte(input))\n\tsha_512.Write([]byte(input))\n\tsha_512_256 := sha512.Sum512_256([]byte(input))\n\thmac512 := hmac.New(sha512.New, []byte(\"secret\"))\n\thmac512.Write([]byte(input))\n\n\t\/\/4db45e622c0ae3157bdcb53e436c96c5\n\tfmt.Printf(\"md5:\\t\\t%x\\n\", md5.Sum(nil))\n\n\t\/\/eb7a03c377c28da97ae97884582e6bd07fa44724af99798b42593355e39f82cb\n\tfmt.Printf(\"sha256:\\t\\t%x\\n\", sha_256.Sum(nil))\n\n\t\/\/5cdaf0d2f162f55ccc04a8639ee490c94f2faeab3ba57d3c50d41930a67b5fa6915a73d6c78048729772390136efed25b11858e7fc0eed1aa7a464163bd44b1c\n\tfmt.Printf(\"sha512:\\t\\t%x\\n\", sha_512.Sum(nil))\n\n\t\/\/34c614af69a2550a4d39138c3756e2cc50b4e5495af3657e5b726c2ac12d5e60\n\tfmt.Printf(\"sha512_256:\\t%x\\n\", sha_512_256)\n\n\t\/\/GBZ7aqtVzXGdRfdXLHkb0ySp\/f+vV9Zo099N+aSv+tTagUWuHrPeECDfUyd5WCoHBe7xkw2EdpyLWx+Ge4JQKg==\n\tfmt.Printf(\"hmac512:\\t%s\\n\", base64.StdEncoding.EncodeToString(hmac512.Sum(nil)))\n}\n","01-beginner - http":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"net\/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tresponse, err := http.Get(\"http:\/\/golang.org\/\") \/\/ Send a HTTP GET request to the URL\n\tif err != nil {\n\t\tfmt.Printf(\"%s\", err) \/\/ If there is an error, print it and exit\n\t\tos.Exit(1)\n\t} else {\n\t\tdefer response.Body.Close()                    \/\/ Close the connection to prevent a resource leak\n\t\tcontents, err := ioutil.ReadAll(response.Body) \/\/ Read the contents of the HTTP GET\n\t\tif err != nil {                                \/\/ If there is an error\n\t\t\tfmt.Printf(\"%s\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", string(contents)) \/\/ Print the contents of the request\n\t}\n}\n","01-beginner - if":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tif os.Args[1] == \"Hello\" {\n\t\tfmt.Println(\"Hello World\")\n\t} else {\n\t\tfmt.Println(\"Hack the Planet\")\n\t}\n}\n","01-beginner - if2":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc f1(b bool) bool {\n\tfmt.Printf(\"f1: %v\\n\", b)\n\treturn b\n}\n\nfunc f2(b bool) bool {\n\tfmt.Printf(\"f2: %v\\n\", b)\n\treturn b\n}\n\nfunc f3(b bool) bool {\n\tfmt.Printf(\"f3: %v\\n\", b)\n\treturn b\n}\n\nfunc main() {\n\tif f1(true) == true {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tif f1(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND\")\n\tif f1(true) && f2(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND\")\n\tif f1(false) && f2(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND\")\n\tif f1(true) && f2(false) && f3(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nOR\")\n\tif f1(true) || f2(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nOR\")\n\tif f1(true) || f2(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND+OR\")\n\tif f1(true) && f2(false) || f3(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\n(AND)+OR\")\n\tif (f1(true) && f2(false)) || f3(true) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\n(AND)+OR\")\n\tif (f1(true) && f2(true)) || f3(false) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND+(OR)\")\n\tif f1(true) && (f2(false) || f3(true)) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n\n\tfmt.Println(\"\\nAND+(OR)\")\n\tif f1(true) && (f2(true) || f3(false)) {\n\t\tfmt.Println(\"\u2714\")\n\t}\n}\n","01-beginner - input":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\t\/\/arguments\n\tif 1 < len(os.Args) {\n\t\tfmt.Print(len(os.Args) - 1)\n\t\tfmt.Println(\" arguments provided\")\n\t}\n\t\/*\n\t\t\/\/Scanf to wait for an input\n\t\tfmt.Println(\"Enter a number\")\n\t\tvar i int\n\t\t_, err := fmt.Scanf(\"%d\", &i)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"not a number\")\n\t\t} else {\n\t\t\tfmt.Print(i)\n\t\t\tfmt.Println(\" is a number\")\n\t\t}\n\t*\/\n\t\/\/Stdin read buffer\n\tfmt.Println(\"Enter a string\")\n\tbio := bufio.NewReader(os.Stdin)\n\tline, _, err := bio.ReadLine()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\t\/\/fmt.Println(\"you entered \\\"\" + string(line) + \"\\\"\")\n\t\tfor _, char := range string(line) {\n\t\t\tfmt.Println(char)\n\t\t}\n\t}\n}\n","01-beginner - inputs":"\/\/ This is a simple program that shows how to use go in taking inputs from a console... It takes in name and age as inputs and then uses conditionals to see if the age is permitted to continue\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"What's your name? : \")\n\tvar name string\n\tfmt.Scanln(&name)\n\tfmt.Printf(\"How old are you? : \")\n\tvar age int\n\tfmt.Scanln(&age)\n\tif age < 18 {\n\t\tfmt.Println(name, \"You are too young to continue! \")\n\n\t} else {\n\t\tfmt.Println(\"Nice to see you\", name)\n\t}\n}\n","01-beginner - interfaces":"package main\n\nimport \"fmt\"\n\nfunc FuncWithInterface(emptyinterface interface{}) {\n\tswitch t := emptyinterface.(type) {\n\tcase string:\n\t\tfmt.Print(\"type: string\\t\")\n\tcase int:\n\t\tfmt.Print(\"type: int\\t\")\n\tcase bool:\n\t\tfmt.Print(\"type: bool\\t\")\n\tdefault:\n\t\tfmt.Printf(\"type: %v\\t\", t)\n\t}\n\n\tfmt.Printf(\"data: %#v\\n\", emptyinterface)\n}\n\nfunc main() {\n\tvar emptyinterface = [3]interface{}{}\n\n\temptyinterface[0] = 23\n\temptyinterface[1] = \"foobar\"\n\temptyinterface[2] = false\n\n\tfmt.Printf(\"data: %v\\n\", emptyinterface)\n\n\tfor _, v := range emptyinterface {\n\t\tFuncWithInterface(v)\n\t}\n\n}\n","01-beginner - isbn":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tisbnInput := os.Args[1]\n\tisbnClean := strings.Replace(isbnInput, \"-\", \"\", -1)\n\tfmt.Printf(\"ISBN verification of %v: %v\\n\", isbnInput, VerifyISBN(isbnClean))\n}\n\nfunc isNotNumber(n rune) bool {\n\treturn n < '0' || '9' < n\n}\n\nfunc VerifyISBN(code string) bool {\n\tif len(code) == 10 {\n\t\treturn VerifyISBN10(code)\n\t} else if len(code) == 13 {\n\t\treturn VerifyISBN13(code)\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc VerifyISBN10(code string) bool {\n\n\tif len(code) != 10 {\n\t\treturn false\n\t}\n\n\tsum, multiply := 0, 10\n\tfor _, n := range code {\n\n\t\tvar d int\n\t\tswitch {\n\t\tcase n == 'X':\n\t\t\td = 10\n\t\tcase isNotNumber(n):\n\t\t\treturn false\n\t\tdefault:\n\t\t\td = int(n - '0')\n\t\t}\n\n\t\tsum += multiply * d\n\t\tmultiply--\n\t}\n\n\treturn sum%11 == 0\n}\n\nfunc VerifyISBN13(code string) bool {\n\n\tif len(code) != 13 {\n\t\treturn false\n\t}\n\n\tsum, weight := 0, 1\n\tfor _, n := range code[:len(code)-1] {\n\t\tif isNotNumber(n) {\n\t\t\treturn false\n\t\t}\n\t\tsum += int(n-'0') * weight\n\t\tif weight == 1 {\n\t\t\tweight = 3\n\t\t} else {\n\t\t\tweight = 1\n\t\t}\n\t}\n\n\td := 10 - sum%10\n\tif d == 10 {\n\t\td = 0\n\t}\n\n\treturn d == int(code[len(code)-1]-'0')\n}\n","01-beginner - map01":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\n\tm := make(map[string]int)\n\n\tm[\"a\"] = 1\n\tm[\"b\"] = 2\n\n\ta := m[\"a\"]\n\tfmt.Println(\"a: \", a)\n\n\tdelete(m, \"b\")\n\tb, ok := m[\"b\"]\n\tfmt.Println(\"b: \", b)\n\tfmt.Println(\"ok? \", ok)\n}\n","01-beginner - map02":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tcreateMap()\n}\n\nfunc createMap() {\n\t\/\/initialize map with key and value as string\n\tvar stringMap = make(map[string]string)\n\n\t\/\/add keys to map\n\tstringMap[\"A\"] = \"AAA\"\n\tstringMap[\"B\"] = \"BBB\"\n\tstringMap[\"C\"] = \"CCC\"\n\n\tfmt.Print(stringMap)\n\n\t\/\/delete key\n\tdelete(stringMap, \"A\")\n\n\t\/\/initialize map with key and value using a map literal\n\tvar intMap = map[int]string{\n\t\t1: \"one\",\n\t\t2: \"two\",\n\t\t3: \"three\",\n\t}\n\n\tfmt.Print(intMap)\n\n\t\/\/access item from map\n\tvalue, ok := intMap[1] \/\/ok is true if item exists\n\tif ok {\n\t\tfmt.Printf(\"Key = 1; Value =%v\", value)\n\t}\n}\n","01-beginner - math":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Abs(x int) int {\n\tif x > 0 {\n\t\treturn x\n\t}\n\treturn -x\n}\n\nfunc GreatestCommonDivisor(a, b int) int {\n\tfor a != 0 {\n\t\ta, b = b%a, a\n\t}\n\treturn b\n}\n\nfunc LeastCommonMultiple(a, b int) int {\n\treturn a * b \/ GreatestCommonDivisor(a, b)\n}\n\nfunc Sqrt(n int64) int64 {\n\tvar t int64\n\tvar b int64\n\tvar r int64\n\tt = int64(n)\n\tp := int64(1 << 30)\n\tfor p > t {\n\t\tp >>= 2\n\t}\n\tfor ; p != 0; p >>= 2 {\n\t\tb = r | p\n\t\tr >>= 1\n\t\tif t >= b {\n\t\t\tt -= b\n\t\t\tr |= p\n\t\t}\n\t}\n\treturn int64(r)\n}\n\nfunc Prime(n int) int {\n\tvar primeList = []int{2}\n\tisPrime := 1\n\tnum := 3\n\tsqrtNum := 0\n\tfor len(primeList) < n {\n\t\tsqrtNum = int(Sqrt(int64(num)))\n\t\tfor i := 0; i < len(primeList); i++ {\n\t\t\tif num%primeList[i] == 0 {\n\t\t\t\tisPrime = 0\n\t\t\t}\n\t\t\tif primeList[i] > sqrtNum {\n\t\t\t\ti = len(primeList)\n\t\t\t}\n\t\t}\n\t\tif isPrime == 1 {\n\t\t\tprimeList = append(primeList, num)\n\t\t} else {\n\t\t\tisPrime = 1\n\t\t}\n\t\tnum = num + 2\n\t}\n\treturn primeList[n-1]\n}\n\nfunc Sum(numbers ...int) int {\n\tvar sum int\n\tfor i := 0; i < len(numbers); i++ {\n\t\tsum += numbers[i]\n\t}\n\treturn sum\n}\n\nfunc main() {\n\tfmt.Printf(\"Abs(-3): %v\\n\", Abs(-3))\n\tfmt.Printf(\"GreatestCommonDivisor(6,16): %v\\n\", GreatestCommonDivisor(6, 16))\n\tfmt.Printf(\"LeastCommonMultiple(12,24): %v\\n\", LeastCommonMultiple(12, 24))\n\tfmt.Printf(\"Sqrt(9): %v\\n\", Sqrt(9))\n\tfmt.Printf(\"Prime(15): %v\\n\", Prime(15))\n\tfmt.Printf(\"Sum(3,5,7,9): %v\\n\", Sum(3, 5, 7, 9))\n}\n","01-beginner - modulo":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tif i%2 == 0 {\n\t\t\tfmt.Println(i)\n\t\t}\n\t}\n}\n","01-beginner - printf":"package main\n\nimport \"fmt\"\n\ntype exampledata struct {\n\ta, b int\n\tc, d string\n\te, f bool\n\tg, h float64\n}\n\nfunc printx(str string, data exampledata) {\n\tfmt.Printf(\"%\"+str+\":\\t \"+str+\"\\n\", data)\n}\n\nfunc main() {\n\tx := exampledata{0, 1, \"a\", \"b\", true, false, 3.1415926535, 2.357111317192329}\n\n\tprintx(\"%v\", x)\n\t\/\/%v:\t {0 1 a b true false 3.1415926535 2.357111317192329}\n\n\tprintx(\"%+v\", x)\n\t\/\/%+v:\t {a:0 b:1 c:a d:b e:true f:false g:3.1415926535 h:2.357111317192329}\n\n\tprintx(\"%#v\", x)\n\t\/\/%#v:\t main.exampledata{a:0, b:1, c:\"a\", d:\"b\", e:true, f:false, g:3.1415926535, h:2.357111317192329}\n\n\tprintx(\"%t\", x)\n\t\/\/%t:\t {%!t(int=0) %!t(int=1) %!t(string=a) %!t(string=b) true false %!t(float64=3.1415926535) %!t(float64=2.357111317192329)}\n\n\tprintx(\"%T\", x)\n\t\/\/%T:\t main.exampledata\n\n\tprintx(\"%d\", x)\n\t\/\/%d:\t {0 1 %!d(string=a) %!d(string=b) %!d(bool=true) %!d(bool=false) %!d(float64=3.1415926535) %!d(float64=2.357111317192329)}\n\n\tprintx(\"%b\", x)\n\t\/\/%b:\t {0 1 %!b(string=a) %!b(string=b) %!b(bool=true) %!b(bool=false) 7074237751826244p-51 5307742824889076p-51}\n\n\tprintx(\"%c\", x)\n\t\/\/%c:\t {  %!c(string=a) %!c(string=b) %!c(bool=true) %!c(bool=false) %!c(float64=3.1415926535) %!c(float64=2.357111317192329)}\n\n\tprintx(\"%x\", x)\n\t\/\/%x:\t {0 1 61 62 %!x(bool=true) %!x(bool=false) 0x1.921fb54411744p+01 0x1.2db5d2da2faf4p+01}\n\n\tprintx(\"%f\", x)\n\t\/\/%f:\t {%!f(int=0) %!f(int=1) %!f(string=a) %!f(string=b) %!f(bool=true) %!f(bool=false) 3.141593 2.357111}\n\n\tprintx(\"%e\", x)\n\t\/\/%e:\t {%!e(int=0) %!e(int=1) %!e(string=a) %!e(string=b) %!e(bool=true) %!e(bool=false) 3.141593e+00 2.357111e+00}\n\n\tprintx(\"%E\", x)\n\t\/\/%E:\t {%!E(int=0) %!E(int=1) %!E(string=a) %!E(string=b) %!E(bool=true) %!E(bool=false) 3.141593E+00 2.357111E+00}\n\n\tprintx(\"%s\", x)\n\t\/\/%s:\t {%!s(int=0) %!s(int=1) a b %!s(bool=true) %!s(bool=false) %!s(float64=3.1415926535) %!s(float64=2.357111317192329)}\n\n\tprintx(\"%q\", x)\n\t\/\/%s:\t {%!s(int=0) %!s(int=1) a b %!s(bool=true) %!s(bool=false) %!s(float64=3.1415926535) %!s(float64=2.357111317192329)}\n\n\tprintx(\"%p\", x)\n\t\/\/%p:\t %!p(main.exampledata={0 1 a b true false 3.1415926535 2.357111317192329})\n\n\tfmt.Println(\"\\n\\n\", fmt.Sprintf(\"%+v\", x))\n\t\/\/ {a:0 b:1 c:a d:b e:true f:false g:3.1415926535 h:2.357111317192329}\n}\n","01-beginner - random":"package main\n\n\/\/ import required modules\nimport (\n\tcrand \"crypto\/rand\"\n\t\"fmt\"\n\t\"math\/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tfmt.Println(\"math\/rand:\")\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(i, rand.Intn(127))\n\t}\n\n\tfmt.Println(\"crypto\/rand:\")\n\tb := make([]byte, 3)\n\tfor i := 0; i < 10; i++ {\n\t\tcrand.Read(b)\n\t\tnumber := uint32(b[0]) | (uint32(b[1]) << 8) | (uint32(b[2]) << 16)\n\t\tfmt.Println(i, number)\n\t}\n}\n","01-beginner - return":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\nfunc named() (str string) {\n\tstr = \"lorem\"\n\treturn\n}\n\nfunc typed() string {\n\tvar str = \"ipsum\"\n\treturn str\n}\n\n\/\/ main function\nfunc main() {\n\tfmt.Println(named())\n\tfmt.Println(typed())\n}\n","01-beginner - scan":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s string\n\tfmt.Print(\"please insert a string an press enter \")\n\tfmt.Scan(&s)\n\tfmt.Printf(\"read string \\\"%v\\\" from stdin\\n\", s)\n}\n","01-beginner - shell":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os\/exec\"\n)\n\nfunc main() {\n\tout, err := exec.Command(\"echo\", \"Hello\", \"world\").Output()\n\tif err != nil {\n\t\tfmt.Printf(\"%s\", err)\n\t\tos.Exit(1)\n\t} else {\n\t\tfmt.Printf(\"%s\\n\", out)\n\t}\n}\n","01-beginner - slice":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\n\/\/ main function\nfunc main() {\n\tvar str string = \"Lorem ipsum dolor sit amet\"\n\tfmt.Println(str[6:11])\n\n\t\/\/Make a new slice using make\n\ts := make([]string, 3)\n\n\t\/\/Appending elements to existing slice\n\ts = append(s, \"abc\")\n\tfmt.Println(s)\n}\n","01-beginner - sortingInGo":"package main\n\nimport \"fmt\"\nimport \"sort\"\n\nfunc main() {\n\tstrs := []string{\"c\", \"a\", \"b\"}\n\tsort.Strings(strs)\n\tfmt.Println(\"Strings:\", strs)\n\n\tints := []int{7, 2, 4}\n\tsort.Ints(ints)\n\tfmt.Println(\"Ints:   \", ints)\n\n\ts := sort.IntsAreSorted(ints)\n\tfmt.Println(\"Sorted: \", s)\n}\n","01-beginner - split":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\/\/ declare variables\nvar variable string\nvar strarray []string\n\n\/\/ main function\nfunc main() {\n\n\t\/\/ define content of variable\n\tvariable = \"Lorem Ipsum Dolor Sit Amet\"\n\n\t\/\/ print variable\n\tfmt.Println(variable)\n\n\t\/\/ split variable by space\n\tstrarray = strings.Split(variable, \" \")\n\n\t\/\/ do something as often as the array contains elements\n\tfor i := 0; i < len(strarray); i++ {\n\n\t\t\/\/ print the array element defined by i\n\t\tfmt.Println(strarray[i])\n\t}\n}\n","01-beginner - sum_of_digits":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Print(\"Enter digits to sum separated by a space:\")\n\tstr, err := getline()\n\tif err == nil {\n\t\tfmt.Println(\"Here is the result:\", sumNumbers(str))\n\t}\n}\n\nfunc getline() (string, error) {\n\treturn bufio.NewReader(os.Stdin).ReadString('\\n')\n}\n\nfunc sumNumbers(str string) float64 {\n\tvar sum float64\n\tfor _, v := range strings.Fields(str) {\n\t\ti, err := strconv.ParseFloat(v, 64)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n","01-beginner - time":"package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(strconv.FormatInt(time.Now().Unix(), 10))\n\t\/\/1401403874\n\tfmt.Println(time.Now().Format(time.RFC850))\n\t\/\/Friday, 30-May-14 00:51:14 CEST\n\tfmt.Println(time.Now().Format(time.RFC1123Z))\n\t\/\/Fri, 30 May 2014 00:51:14 +0200\n\tfmt.Println(time.Now().Format(\"20060102150405\"))\n\t\/\/20140530005114\n\tfmt.Println(time.Unix(1401403874, 0).Format(\"02.01.2006 15:04:05\"))\n\t\/\/30.05.2014 00:51:14\n\tfmt.Println(time.Unix(123456789, 0).Format(time.RFC3339))\n\t\/\/1973-11-29T22:33:09+01:00\n\tfmt.Println(time.Unix(1234567890, 0).Format(time.RFC822))\n\t\/\/14 Feb 09 00:31 CET\n}\n","01-beginner - var":"package main\n\n\/\/ import required modules\nimport (\n\t\"fmt\"\n)\n\n\/\/ declare variables\nvar variable string\n\nfunc main() {\n\n\t\/\/ define content of variable\n\tvariable = \"Lorem Ipsum Dolor Sit Amet\"\n\n\t\/\/ print variable\n\tfmt.Println(variable)\n}\n","02-advanced - advancedimport":"package main\n\nimport (\n\t\/\/ You can import a package to your own namespace, so you don't have to write the package\n\t\/\/ name in front of the imported function name. Use this import method wisely.\n\t\/\/ By wisely i mean don't use it unless you have a really good reason for.\n\t. \".\/packages\"\n\t\/\/ If you wan't to import a package but don't need any function of the package, you can\n\t\/\/ do it like this (you only need it very rarely, e.g. for database \"drivers\"\n\t\/\/ or for image format \"drivers\"):\n\t_ \".\/packages\/withInit\"\n\t\/\/ If you wan't to import a package with a different name, you can write the alias and then\n\t\/\/ the package name like this:\n\tf \"fmt\"\n)\n\nfunc main() {\n\tf.Printf(\"use function PlusOne from \\\".\/packages\/\\\" without namespace: %d\\n\", PlusOne(2))\n}\n","02-advanced - aesgcm":"package main\n\nimport (\n\t\"crypto\/aes\"\n\t\"crypto\/cipher\"\n\t\"crypto\/rand\"\n\t\"fmt\"\n\t\"io\"\n)\n\n\/\/ AesGcmEncrypt takes an encryption key and a plaintext string and encrypts it with AES256 in GCM mode, which provides authenticated encryption. Returns the ciphertext and the used nonce.\nfunc AesGcmEncrypt(key []byte, plaintext string) (ciphertext, nonce []byte) {\n\tplaintextBytes := []byte(plaintext)\n\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t\/\/ Never use more than 2^32 random nonces with a given key because of the risk of a repeat.\n\tnonce = make([]byte, 12)\n\tif _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\taesgcm, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tciphertext = aesgcm.Seal(nil, nonce, plaintextBytes, nil)\n\tfmt.Printf(\"Ciphertext: %x\\n\", ciphertext)\n\tfmt.Printf(\"Nonce: %x\\n\", nonce)\n\n\treturn\n}\n\n\/\/ AesGcmDecrypt takes an decryption key, a ciphertext and the corresponding nonce and decrypts it with AES256 in GCM mode. Returns the plaintext string.\nfunc AesGcmDecrypt(key, ciphertext, nonce []byte) (plaintext string) {\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\taesgcm, err := cipher.NewGCM(block)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tplaintextBytes, err := aesgcm.Open(nil, nonce, ciphertext, nil)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tplaintext = string(plaintextBytes)\n\tfmt.Printf(\"%s\\n\", plaintext)\n\n\treturn\n}\n\nfunc main() {\n\t\/\/ Generate an encryption key. 16 bytes = AES-128, 32 bytes = AES-256.\n\tkey := make([]byte, 32)\n\tif _, err := io.ReadFull(rand.Reader, key); err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\t\/\/ Specify the plaintext input\n\tplaintext := \"Lorem Ipsum\"\n\tciphertext, nonce := AesGcmEncrypt(key, plaintext)\n\n\t\/\/ For decryption you need to provide the nonce which was used for the encryption\n\tplaintext = AesGcmDecrypt(key, ciphertext, nonce)\n}\n","02-advanced - binary_search":"package main\n\nimport \"fmt\"\n\nfunc binarySearch(element int, arr []int) bool {\n\tlow := 0\n\thigh := len(arr) - 1\n\n\tfor low <= high {\n\t\tmid := (low + high) \/ 2\n\n\t\tif arr[mid] < element {\n\t\t\tlow = mid + 1\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\n\tif low == len(arr) || arr[low] != element {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc main() {\n\tarr := []int{1, 4, 5, 7, 9, 10, 35, 56, 79, 80, 100, 200, 210, 250}\n\tfmt.Println(binarySearch(9, arr))\n}\n","02-advanced - bound":"package main\n\nimport \"fmt\"\n\nfunc lowerBound(arr []int, target int) int {\n\tlow := 0\n\thigh := len(arr) - 1\n\tmid := 0\n\n\tfor low <= high {\n\t\tmid = (low + high) \/ 2\n\t\tif arr[mid] >= target {\n\t\t\thigh = mid - 1\n\t\t} else {\n\t\t\tlow = mid + 1\n\t\t}\n\t}\n\treturn low\n}\n\nfunc upperBound(arr []int, target int) int {\n\tlow := 0\n\thigh := len(arr) - 1\n\tmid := 0\n\n\tfor low <= high {\n\t\tmid = (low + high) \/ 2\n\t\tif arr[mid] > target {\n\t\t\thigh = mid - 1\n\t\t} else {\n\t\t\tlow = mid + 1\n\t\t}\n\t}\n\treturn low\n}\n\nfunc main() {\n\tarr := []int{1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 6, 6, 7, 7, 7}\n\tfmt.Printf(\"%s%d\\n\", \"Lower bound of 4: \", lowerBound(arr, 4))\n\tfmt.Printf(\"%s%d\\n\", \"Upper bound of 4: \", upperBound(arr, 4))\n}\n","02-advanced - channel":"package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"time\"\n)\n\nvar chan_int chan int\nvar stop_bool chan bool\n\nfunc init() {\n\tchan_int = make(chan int, 2)\n\tstop_bool = make(chan bool, 3)\n}\n\nfunc maxprocs1() {\n\t\/*\n\t * Channels are useful for communications between multiple\n\t * go routines, even when the routines are not runned in parallel.\n\t *\n\t *\/\n\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"1\")\n\t\tstop_bool <- true\n\t}()\n\tgo func() {\n\t\ttime.Sleep(1900 * time.Millisecond)\n\t\tfmt.Println(\"2\")\n\t\tstop_bool <- true\n\t}()\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tfmt.Println(\"3\")\n\t\tstop_bool <- true\n\t}()\n\n\t<-stop_bool\n\t<-stop_bool\n\t<-stop_bool\n\n\t\/*\n\t * the previous code is compareable to the following bash code:\n\t *\n\t * function1 &\n\t * stop1=$!\n\t *\n\t * function2 &\n\t * stop2=$!\n\t *\n\t * function3 &\n\t * stop3=$!\n\t *\n\t * wait $stop1\n\t * wait $stop2\n\t * wait $stop3\n\t *\n\t *\/\n}\n\nfunc waitforbuffer() {\n\t\/*\n\t *\n\t * Starts a go routine which waits 2 seconds, prints the value\n\t * from the channel buffer and waits again (over and over again).\n\t * In the parrent function it tries to fill the channel with 3 integers,\n\t * but after the first two values it has to wait until the buffer gets\n\t * emptied. After 2 seconds, the first value gets loaded and printed,\n\t * so the next value can be saved (but will never be printed, because\n\t * the programm no longer have to wait for the channel and quit.\n\t *\n\t *\/\n\n\tgo func(i int) {\n\t\tfor {\n\t\t\ttime.Sleep(time.Duration(i) * time.Second)\n\t\t\tfmt.Println(<-chan_int)\n\t\t}\n\t}(2)\n\tfmt.Println(\"start\")\n\tchan_int <- 1\n\tfmt.Println(\"<-1\")\n\tchan_int <- 2\n\tfmt.Println(\"<-2\")\n\tchan_int <- 3\n\tfmt.Println(\"<-3\")\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(1)\n\tfmt.Println(\"starting maxprocs1()\")\n\tmaxprocs1()\n\tfmt.Println(\"starting waitforbuffer()\")\n\twaitforbuffer()\n\tfmt.Println(\"finish\")\n}\n","02-advanced - channel_range":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tqueue := make(chan int, 6)\n\tqueue <- 23\n\tqueue <- 42\n\tqueue <- 1337\n\tqueue <- 9999\n\tclose(queue)\n\n\tfor elem := range queue {\n\t\tfmt.Println(elem)\n\t}\n}\n","02-advanced - command_line_arguments":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tenv := flag.String(\"env\", \"dev\", \"Environment(dev, qa, stg, prod)\")\n\tcron := flag.Bool(\"consumer\", false, \"boolean\")\n\t\/\/Parse parses the command-line flags\n\tflag.Parse()\n\tfmt.Println(\"The environment set is\", *env)\n\tfmt.Println(\"The consumer flag retrieved from command line is\", *cron)\n}\n","02-advanced - compress":"package main\n\nimport (\n\t\"compress\/gzip\"\n\t\"flag\"\n\t\"io\"\n\t\"os\"\n)\n\nvar n = flag.Int(\"n\", 6, \"Compression level (0-9)\")\n\nfunc main() {\n\tflag.Parse()\n\tc, _ := gzip.NewWriterLevel(os.Stdout, *n)\n\n\tio.Copy(c, os.Stdin)\n\tc.Close()\n}\n","02-advanced - compress2":"package main\n\nimport (\n\t\"compress\/flate\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc decompress(inputFile, outputFile string) {\n\ti, _ := os.Open(inputFile)\n\tdefer i.Close()\n\tf := flate.NewReader(i)\n\tdefer f.Close()\n\to, _ := os.Create(outputFile)\n\tdefer o.Close()\n\tio.Copy(o, f)\n}\n\nfunc compress(inputFile, outputFile string) {\n\ti, _ := os.Open(inputFile)\n\tdefer i.Close()\n\to, _ := os.Create(outputFile)\n\tdefer o.Close()\n\tf, _ := flate.NewWriter(o, flate.BestCompression)\n\tdefer f.Close()\n\tio.Copy(f, i)\n}\n\nfunc main() {\n\tcompress(\"compress.go\", \"compress.min\")\n\tdecompress(\"compress.min\", \"compress_1.go\")\n}\n","02-advanced - csv":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding\/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc LoadCSVfromFile(filename string) (map[int][]string, map[string]int) {\n\tfp, _ := os.Open(filename)\n\treturn loadCSV(bufio.NewReader(fp))\n}\n\nfunc LoadCSVfromString(csv string) (map[int][]string, map[string]int) {\n\tfp := strings.NewReader(csv)\n\treturn loadCSV(fp)\n}\n\nfunc loadCSV(reader io.Reader) (map[int][]string, map[string]int) {\n\tvar row int\n\tvar head = map[int][]string{}\n\tvar data = map[int][]string{}\n\n\tcsvReader := csv.NewReader(reader)\n\tcsvReader.Comma = ';'\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\n\t\tif row == 0 {\n\t\t\thead[row] = record\n\t\t} else {\n\t\t\tdata[row] = record\n\t\t}\n\t\trow++\n\t}\n\treturn data, GetHead(head)\n}\n\nfunc GetHead(data map[int][]string) map[string]int {\n\thead := make(map[string]int, len(data[0]))\n\tfor pos, name := range data[0] {\n\t\thead[name] = pos\n\t}\n\treturn head\n}\n\nvar userdata string = `id;name;email\n0;John Doe;jDoe@example.org\n1;Jane Doe;jane.doe@example.com\n2;Max Mustermann;m.mustermann@alpha.tld`\n\nfunc main() {\n\tcsvmap, k := LoadCSVfromString(userdata)\n\tfor _, user := range csvmap {\n\t\tfmt.Println(user[k[\"name\"]])\n\t}\n}\n","02-advanced - csv2md":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding\/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc fixedLengthBefore(str string, spacer string, length int) string {\n\tspacer = spacer[:1]\n\tl := length - len(str)\n\tif l > 0 {\n\t\treturn strings.Repeat(spacer, l) + str\n\t}\n\tif l == 0 {\n\t\treturn str\n\t}\n\treturn str[:length]\n}\n\nfunc convertCSVtoMD(filename string) string {\n\tfp, _ := os.Open(filename)\n\n\tvar row int\n\tvar columnLength = map[int]int{}\n\tvar data = map[int][]string{}\n\n\tcsvReader := csv.NewReader(bufio.NewReader(fp))\n\tcsvReader.Comma = ';'\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tfor k := range record {\n\t\t\tclen := len(record[k])\n\t\t\tif columnLength[k] < clen {\n\t\t\t\tcolumnLength[k] = clen\n\t\t\t}\n\t\t}\n\t\tdata[row] = record\n\t\trow++\n\t}\n\n\tvar md string\n\tvar mdHeader string\n\theader := true\n\tfor row = 0; row < len(data); row++ {\n\t\tfor colKey := range data[row] {\n\t\t\tif colKey != 0 {\n\t\t\t\tmd += \"|\"\n\t\t\t}\n\t\t\tmd += fixedLengthBefore(data[row][colKey], \" \", columnLength[colKey])\n\t\t\tif header {\n\t\t\t\tif colKey != 0 {\n\t\t\t\t\tmdHeader += \"|\"\n\t\t\t\t}\n\t\t\t\tmdHeader += strings.Repeat(\"-\", columnLength[colKey])\n\t\t\t}\n\t\t}\n\t\tmd += \"\\n\"\n\t\tif header {\n\t\t\tmd += mdHeader + \"\\n\"\n\t\t\theader = false\n\t\t}\n\t}\n\treturn md\n}\n\nfunc main() {\n\tfmt.Println(convertCSVtoMD(\"example.csv\"))\n}\n","02-advanced - debug":"package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"log\"\n\t\"path\"\n\t\"runtime\"\n\t\"runtime\/debug\"\n\t\"runtime\/trace\"\n)\n\nvar (\n\tdunno     = []byte(\"???\")\n\tcenterDot = []byte(\"\u00b7\")\n\tdot       = []byte(\".\")\n\tslash     = []byte(\"\/\")\n)\n\nfunc source(lines [][]byte, n int) []byte {\n\tif n < 0 || n >= len(lines) {\n\t\treturn dunno\n\t}\n\treturn bytes.Trim(lines[n], \" \\t\")\n}\n\nfunc function(pc uintptr) []byte {\n\tfn := runtime.FuncForPC(pc)\n\tif fn == nil {\n\t\treturn dunno\n\t}\n\tname := []byte(fn.Name())\n\tif lastslash := bytes.LastIndex(name, slash); lastslash >= 0 {\n\t\tname = name[lastslash+1:]\n\t}\n\tif period := bytes.Index(name, dot); period >= 0 {\n\t\tname = name[period+1:]\n\t}\n\tname = bytes.Replace(name, centerDot, dot, -1)\n\treturn name\n}\n\nfunc debugExample() []byte {\n\tbuf := new(bytes.Buffer)\n\tvar lines [][]byte\n\tvar lastFile string\n\tfor i := 0; ; i++ {\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif file != lastFile {\n\t\t\tdata, err := ioutil.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{'\\n'})\n\t\t\tlastFile = file\n\t\t}\n\t\tline--\n\t\tfn, _ := path.Split(file)\n\t\tfmt.Fprintf(buf, \"%s:%s:%d: %s\\n\", fn, function(pc), line+1, source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\nfunc fn3() {\n\tfmt.Printf(\"%v\\n\", string(debugExample()))\n}\n\nfunc fn2() {\n\tfn3()\n}\n\nfunc fn() {\n\tlog.Printf(\"log inside a function\")\n\tdebug.PrintStack()\n\tlog.Printf(\"%v\\n\", string(debug.Stack()))\n\tfn2()\n}\n\nfunc main() {\n\tvar b bytes.Buffer\n\ttrace.Start(&b)\n\tlog.SetFlags(log.Ltime | log.Lshortfile)\n\n\tlog.Println(\"first log output\")\n\tlog.Printf(\"second log output\\n\")\n\tfn()\n\tlog.Printf(\"tace: %v\\n\", b.String())\n}\n","02-advanced - deferpanic":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfunc() {\n\t\tdefer func() {\n\t\t\tfmt.Println(\"1st lvl defer\")\n\t\t}()\n\t\tfmt.Println(\"1st lvl start\")\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tfmt.Println(\"2nd lvl defer\")\n\t\t\t\tfmt.Println(\"recover\", recover())\n\t\t\t}()\n\t\t\tfmt.Println(\"2nd lvl start\")\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tfmt.Println(\"3rd lvl defer\")\n\t\t\t\t}()\n\t\t\t\tfmt.Println(\"3rd lvl start\")\n\t\t\t\tfunc() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tfmt.Println(\"4th lvl defer\")\n\t\t\t\t\t}()\n\t\t\t\t\tfmt.Println(\"4th lvl start\")\n\t\t\t\t\tfmt.Println(\"panic\")\n\t\t\t\t\tpanic(0)\n\t\t\t\t\tfmt.Println(\"4th lvl finish\")\n\t\t\t\t}()\n\t\t\t\tfmt.Println(\"3rd lvl finish\")\n\t\t\t}()\n\t\t\tfmt.Println(\"2nd lvl finish\")\n\t\t}()\n\t\tfmt.Println(\"1st lvl finish\")\n\t}()\n}\n","02-advanced - deferpanic2":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tstop := 10\n\tfor i := 0; i < 15; i++ {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\trecover()\n\t\t\t}()\n\n\t\t\tif i == 10 {\n\t\t\t\tfmt.Println(\"i10\")\n\t\t\t\tpanic(0)\n\t\t\t}\n\t\t\tif i == 14 {\n\t\t\t\tfmt.Println(\"i14\")\n\t\t\t\ti = 0\n\t\t\t\tstop--\n\t\t\t\tpanic(0)\n\t\t\t}\n\t\t}()\n\t\tif stop == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n","02-advanced - exec":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\/exec\"\n\t\"strings\"\n)\n\nfunc pipe_cmd(cmds ...*exec.Cmd) ([]byte, error) {\n\tfor i, cmd := range cmds[:len(cmds)-1] {\n\t\tout, err := cmd.StdoutPipe()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcmd.Start()\n\t\tcmds[i+1].Stdin = out\n\t}\n\n\tret, err := cmds[len(cmds)-1].Output()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ret, nil\n}\n\nfunc main() {\n\tdatestr, err := exec.Command(\"date\").Output()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Print(\"Date String: \", string(datestr))\n\n\tvar datecmd *exec.Cmd\n\tvar lscmd *exec.Cmd\n\n\t\/\/of course the following lines are really useless (they are only for example purposes)\n\tdatecmd = exec.Command(\"date\", \"+%d.%m.%Y %H:%M:%S\")\n\tgrep1 := exec.Command(\"grep\", \"-o\", \"\\\\d\\\\d.\\\\d\\\\d.\\\\d\\\\d\\\\d\\\\d\")\n\tdate, err1 := pipe_cmd(datecmd, grep1)\n\n\tdatecmd = exec.Command(\"date\", \"+%d.%m.%Y %H:%M:%S\")\n\tgrep2 := exec.Command(\"grep\", \"-o\", \"\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d\")\n\ttime, err2 := pipe_cmd(datecmd, grep2)\n\n\tlscmd = exec.Command(\"ls\", \"-ltraR\", \".\/\")\n\tgrep3 := exec.Command(\"grep\", \"-o\", \"[^ \\\\.\/]\\\\+\\\\.[^ \\\\.\/]\\\\+\")\n\tfiles, err3 := pipe_cmd(lscmd, grep3)\n\n\tif err1 != nil {\n\t\tfmt.Print(err1)\n\t} else {\n\t\tfmt.Print(\"Date: \", string(date))\n\t}\n\n\tif err2 != nil {\n\t\tfmt.Print(err2)\n\t} else {\n\t\tfmt.Print(\"Time: \", string(time))\n\t}\n\n\tcounter := make(map[string]int)\n\tvar ok bool\n\tif err3 != nil {\n\t\tfmt.Print(err3)\n\t} else {\n\t\tstrarray := strings.Split(string(files), \"\\n\")\n\t\tfor i := 0; i < len(strarray); i++ {\n\t\t\tif strings.Trim(strarray[i], \" .\") != \"\" {\n\t\t\t\tif _, ok = counter[strarray[i]]; ok {\n\t\t\t\t\tcounter[strarray[i]]++\n\t\t\t\t} else {\n\t\t\t\t\tcounter[strarray[i]] = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(\"Files: \", counter)\n\t}\n}\n","02-advanced - fanin":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n\/\/ returns a read only channel\nfunc generator(start, end int) <-chan int {\n\tc := make(chan int) \/\/ ubuffered channel\n\n\t\/\/ Fire a goroutine to send values on the channel\n\tgo func() {\n\t\tfor i := start; i < end; i++ {\n\t\t\tc <- i \/\/ This blocks until there is a reader for the chan\n\t\t}\n\t\t\/\/ close the channel when done; otherwise it leaks resources\n\t\tclose(c)\n\t}()\n\n\treturn c\n}\n\n\/* The fan in pattern is an important pattern which combines\nmultiple channels, returns a single channel from those channels\n*\/\n\nfunc fanIn(chans ...<-chan int) chan int {\n\tvar wg sync.WaitGroup\n\n\tc := make(chan int)\n\n\t\/\/ Closure to send values from a channel\n\toutput := func(ch <-chan int) {\n\t\tfor n := range ch {\n\t\t\tc <- n\n\t\t}\n\t\twg.Done()\n\t}\n\n\twg.Add(len(chans))\n\n\t\/\/ send values on c via different goroutines\n\tfor _, ch := range chans {\n\t\tgo output(ch)\n\t}\n\n\t\/\/ wait for all goroutines to finish before closing the channel\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(c)\n\t}()\n\n\treturn c\n}\n\nfunc main() {\n\ts1 := generator(1, 10)\n\ts2 := generator(20, 30)\n\ts3 := generator(40, 50)\n\ts4 := generator(60, 70)\n\n\t\/\/ merge all the channels into one\n\tmergerd := fanIn(s1, s2, s3, s4)\n\n\tfor n := range mergerd { \/\/ range loop terminates once the chan is closed, otherwise it blocks if there is no value\n\t\tfmt.Println(n)\n\t}\n}\n","02-advanced - fibonacci":"package main\n\n\/\/ import required modules\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar x uint64\n\nfunc main() {\n\tstart := time.Now()\n\tflag.Parse()\n\ts := flag.Arg(0)\n\n\tif s == \"\" {\n\t\ts = \"140\"\n\t}\n\n\tx, err := strconv.ParseUint(s, 10, 0)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tx = 40\n\t}\n\n\tfibonacci(x)\n\telapsed := time.Since(start)\n\tfmt.Println(\"\\ntime:\", elapsed)\n}\n\nfunc fibonacci(n uint64) {\n\tvar a uint64 = 0\n\tvar b uint64 = 1\n\tvar i uint64\n\tvar sum uint64\n\tfor i = 0; i < n; i++ {\n\t\tfmt.Println(a)\n\t\tsum = a + b\n\t\ta = b\n\t\tb = sum\n\t}\n}\n","02-advanced - file":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\nfunc check(e error) {\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc main() {\n\tfilename := \".\/file.go\"\n\n\t\/\/os.Stat returns file info\n\tfinfo, err := os.Stat(filename)\n\tif err != nil {\n\t\tfmt.Println(filename + \" doesn't exist\")\n\t} else {\n\n\t\t\/\/IsDir returns boolean true if finfo is a directory\n\t\tif finfo.IsDir() {\n\t\t\tfmt.Println(filename + \" is a directory\")\n\t\t} else {\n\n\t\t\t\/\/ReadFile returns the input of the file\n\t\t\tgofile, err1 := ioutil.ReadFile(filename)\n\t\t\tcheck(err1)\n\t\t\toutput := []byte(gofile)\n\t\t\tfmt.Println(string(gofile))\n\n\t\t\t\/\/WriteFile writes data to a file\n\t\t\terr2 := ioutil.WriteFile(\".\/file.txt\", output, 0644)\n\t\t\tcheck(err2)\n\t\t}\n\t}\n}\n","02-advanced - file_embed":"package main\n\nimport (\n\t\"embed\"\n\t\"fmt\"\n\t\"log\"\n)\n\n\/\/go:embed example.csv\nvar fileString string\n\n\/\/go:embed packages\/*.go\nvar folder embed.FS\n\nfunc main() {\n\tfmt.Println(\"example.csv:\")\n\tfmt.Println(fileString)\n\n\tfiles, err := folder.ReadDir(\"packages\")\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"\\nEmbedded files:\")\n\tfor _, file := range files {\n\t\tfmt.Println(file.Name())\n\t}\n\n\tcontent, _ := folder.ReadFile(\"packages\/foobar.go\")\n\tfmt.Println(\"\\npackages\/foobar.go:\")\n\tfmt.Println(string(content))\n}\n","02-advanced - functionanonymous":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tstop := make(chan bool)\n\n\tgo func() {\n\t\tfmt.Println(\"this is Println inside an anonymous goroutine\")\n\t\tstop <- true\n\t}()\n\tfunc() {\n\t\tfmt.Println(\"this is Println inside an anonymous function\")\n\t}()\n\t<-stop\n}\n","02-advanced - functionbyname":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc f1() string {\n\treturn \"foo\"\n}\nfunc f2() string {\n\treturn \"bar: \"\n}\nfunc f3() string {\n\treturn \"lorem \"\n}\nfunc f4() string {\n\treturn \"ipsum \"\n}\nfunc f5() string {\n\treturn \"dolor \"\n}\nfunc f6() string {\n\treturn \"sit \"\n}\nfunc f7() string {\n\treturn \"amet.\"\n}\n\nfunc main() {\n\tfuncs := map[string]func() string{\n\t\t\"f1\": f1,\n\t\t\"f2\": f2,\n\t\t\"f3\": f3,\n\t\t\"f4\": f4,\n\t\t\"f5\": f5,\n\t\t\"f6\": f6,\n\t\t\"f7\": f7,\n\t}\n\n\tvar str string\n\tfor i := 1; i < 8; i++ {\n\t\tx := fmt.Sprintf(\"%v\", i)\n\t\tstr += funcs[\"f\"+x]()\n\t}\n\tfmt.Println(str)\n}\n","02-advanced - functioncallback":"package main\n\nimport \"fmt\"\n\nfunc timestwo(f func(int) int, x int) int {\n\treturn f(x * 2)\n}\n\nfunc main() {\n\tfmt.Printf(\"%v\\n\", timestwo(func(i int) int {\n\t\treturn i * 2\n\t}, 32))\n}\n","02-advanced - functionclosure":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc initTimeSeq() func() int {\n\tt := time.Now().UnixNano()\n\treturn func() int {\n\t\treturn int(time.Now().UnixNano() - t)\n\t}\n}\n\nfunc main() {\n\ttimeSince := initTimeSeq()\n\n\tfmt.Println(timeSince())\n\n\tfmt.Println(timeSince())\n\n\ttime.Sleep(1 * time.Second)\n\n\tfmt.Println(timeSince())\n\n\ttime.Sleep(120 * time.Millisecond)\n\n\tfmt.Println(timeSince())\n\n\ttimeSince = initTimeSeq()\n\n\ttime.Sleep(1300 * time.Millisecond)\n\n\tfmt.Println(timeSince())\n\n\tfmt.Println(timeSince())\n\n\tfmt.Println(timeSince())\n}\n","02-advanced - functionmain":"package main\n\nimport (\n\t\"fmt\"\n)\n\nvar i int\n\nfunc init() {\n\tfmt.Println(\"the init function gets started at first\")\n}\n\nfunc main() {\nRESTART:\n\tfmt.Println(\"the main function gets called immediately after\")\n\tif i < 3 {\n\t\ti++\n\t\tfmt.Println(\"we can also call the main function ourself (but not init)\")\n\t\tgoto RESTART\n\t}\n}\n","02-advanced - functionvariadic":"package main\n\nimport \"fmt\"\n\nfunc sum(numbers ...int) int {\n\tvar total int = 0\n\tfor _, number := range numbers {\n\t\ttotal += number\n\t}\n\treturn total\n}\n\nfunc main() {\n\tfmt.Println(sum(2, 3, 5, 7, 11, 13, 17, 19, 23, 29))\n\n\tnumbers := []int{31, 37, 41, 43, 47, 53, 59}\n\n\tfmt.Println(sum(numbers...))\n}\n","02-advanced - generic":"package main\n\nimport \"fmt\"\n\n\/\/ Int is a type constraint. It can be used to indicate that a function can accept the\n\/\/ types listed within the constraint, in this case int, int32 and int64.\ntype Int interface {\n\tint | int32 | int64\n}\n\n\/\/ Float is also a type constraint but describe type float32 and float64.\ntype Float interface {\n\tfloat32 | float64\n}\n\n\/\/ The Number used the Int and Float constraint. In this case it has the same effect as\n\/\/\n\/\/\ttype Number interface {\n\/\/\t\tint | int32 | int64 | float32 | float64\n\/\/\t}\ntype Number interface {\n\tInt | Float\n}\n\nfunc main() {\n\t\/\/ Initialize a map for the integer values\n\tints := []int64{6, 3, 555}\n\n\t\/\/ Initialize a map for the float values\n\tfloats := []float64{35.98, 26.99, 933.0001, 3.14}\n\n\tfmt.Printf(\"(Non-Generic) SumInts: %v, SumFloats: %v\\n\",\n\t\tSumInts(ints),\n\t\tSumFloats(floats))\n\n\tfmt.Printf(\"(type explicitly specified) SumIntsOrFloats: %v, SumIntsOrFloats: %v\\n\",\n\t\tSumIntsOrFloats[int64](ints),\n\t\tSumIntsOrFloats[float64](floats))\n\n\tfmt.Printf(\"(type infered) SumIntsOrFloats: %v, SumIntsOrFloats: %v\\n\",\n\t\tSumIntsOrFloats(ints),\n\t\tSumIntsOrFloats(floats))\n\n\tfmt.Printf(\"(With Constraint) SumIntsGeneric: %v, SumIntsGeneric: %v\\n\",\n\t\tSumIntsGeneric(ints),\n\t\tSumFloatsGeneric(floats))\n\n\tfmt.Printf(\"(With Constraint) SumNumbers: %v, SumNumbers: %v\\n\",\n\t\tSumNumbers(ints),\n\t\tSumNumbers(floats))\n}\n\n\/\/ SumInts sums the values in s. (Non-Generic)\nfunc SumInts(s []int64) int64 {\n\tvar sum int64\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\n\/\/ SumFloats sums the values in s. (Non-Generic)\nfunc SumFloats(s []float64) float64 {\n\tvar sum float64\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\n\/\/ SumIntsGeneric sums the values in s. It supports both Int slice. (Generic)\nfunc SumIntsGeneric[V Int](s []V) V {\n\tvar sum V\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\n\/\/ SumFloatsGeneric sums the values in s. It supports both Float slice. (Generic)\nfunc SumFloatsGeneric[V Float](s []V) V {\n\tvar sum V\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\n\/\/ SumIntsOrFloats sums the values in slice s. It supports both int64 and float64 slice. (Generic)\nfunc SumIntsOrFloats[V int64 | float64](s []V) V {\n\tvar sum V\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\n\/\/ SumNumbers sums the values in s. Its supports any type that fulfill Number constraint. (Generic)\n\/\/ Note: This function header can also be written as\n\/\/\n\/\/\tfunc SumNumbers[V Int | Float](s []V) V\nfunc SumNumbers[V Number](s []V) V {\n\tvar sum V\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\treturn sum\n}\n","02-advanced - getchar":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os\/exec\"\n)\n\nfunc readStdin(out chan string, in chan bool) {\n\t\/\/no buffering\n\texec.Command(\"stty\", \"-f\", \"\/dev\/tty\", \"cbreak\", \"min\", \"1\").Run()\n\t\/\/no visible output\n\texec.Command(\"stty\", \"-f\", \"\/dev\/tty\", \"-echo\").Run()\n\n\tvar b []byte = make([]byte, 1)\n\tfor {\n\t\tselect {\n\t\tcase <-in:\n\t\t\treturn\n\t\tdefault:\n\t\t\tos.Stdin.Read(b)\n\t\t\tfmt.Printf(\">>> %v: \", b)\n\t\t\tout <- string(b)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tdefer func() {\n\t\texec.Command(\"stty\", \"-f\", \"\/dev\/tty\", \"echo\").Run()\n\t}()\n\tstdin := make(chan string, 1)\n\tkill := make(chan bool, 1)\n\tvar count int = 0\n\tvar input string\n\n\tfmt.Print(\"this program don't wait for a enter-key\\nyou can now start typing\\npress \\\"q\\\" to quit\\n\\n\")\n\n\tgo readStdin(stdin, kill)\n\tfor {\n\t\tstr := <-stdin\n\n\t\tif str == \"q\" {\n\t\t\tkill <- true\n\t\t\tclose(stdin)\n\t\t\tbreak\n\t\t}\n\n\t\tfmt.Println(str)\n\t\tinput += str\n\t\tcount++\n\n\t\tif count%10 == 0 {\n\t\t\tfmt.Printf(\"\\n\\nyou typed %v keys, quit the demo by pressing \\\"q\\\"\\n\\n\", count)\n\t\t\tif count == 600 {\n\t\t\t\tfmt.Printf(\"Don't waste your time! Do something meaningful!\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"\\n\\nyou typed %v keys before you quit the program\\n\", count)\n\tfmt.Println(input)\n}\n","02-advanced - httpupload":"package main\n\nimport (\n\t\"html\/template\"\n\t\"io\"\n\t\"log\"\n\t\"net\/http\"\n\t\"os\"\n)\n\nvar templates *template.Template\nvar uploadDir string\n\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n\ttemplates.Execute(w, data)\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tswitch r.Method {\n\t\/\/GET requests will be redirected\n\tcase \"GET\":\n\t\t\/\/ redirect to . (http:\/\/localhost:8080\/)\n\t\thttp.Redirect(w, r, \".\", 301)\n\n\t\/\/POST takes the uploaded file(s) and saves it to disk\n\tcase \"POST\":\n\t\t\/\/get the multipart reader for the request\n\t\treader, err := r.MultipartReader()\n\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t\/\/copy each part to dir\n\t\tfor {\n\t\t\tpart, err := reader.NextPart()\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t\/\/if FileName() is empty, skip this part\n\t\t\tif part.FileName() == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdst, err := os.Create(uploadDir + part.FileName())\n\t\t\tif err == nil {\n\t\t\t\tdefer dst.Close()\n\t\t\t\tlog.Println(\"file upload started:\", part.FileName())\n\t\t\t} else {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := io.Copy(dst, part); err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tlog.Println(\"file uploaded:\", part.FileName())\n\t\t\t}\n\t\t}\n\t\t\/\/display success message via html template\n\t\tdisplay(w, \"upload\", \"Upload successful.\")\n\tdefault:\n\t\t\/\/only allow GET- and POST-Requests, otherwise respond with HTTP-Code 405\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc formHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.RawQuery == \"\" && r.Method == \"GET\" {\n\t\tdisplay(w, \"upload\", nil)\n\t}\n}\n\nfunc main() {\n\tuploadDir = \".\/\"\n\ttemplates, _ = template.New(\"tmpl\").Parse(templateString)\n\n\thttp.HandleFunc(\"\/upload\", uploadHandler)\n\thttp.HandleFunc(\"\/\", formHandler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n\/\/ this is the HTML template - usually this would be stored in a separate file\nvar templateString = `\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<title>File Upload Example<\/title>\n\t\t<style>\n\t\t\tbody {\n\t\t\t\t\tfont-family: Sans-serif;\n\t\t\t\t\tpadding-bottom: 20px;\n\t\t\t\t\tbackground-color: #ffffff;\n\t\t\t}\n\t\t\th1 a {\n\t\t\t\tcolor: black;\n\t\t\t\ttext-decoration: none;\n\t\t\t}\n\t\t\th1 {text-align: left; margin-bottom: 20px;}\n\t\t\t.message {font-weight:bold}\n\t\t\tfieldset {width:400px}\n\t\t<\/style>\n\t<\/head>\n\t<body>\n\t\t<div class=\"container\">\n\t\t\t<h1><a href=\".\/\">File Upload Example<\/a><\/h1>\n\t\t\t<div class=\"message\">{{.}}<\/div>\n\t\t\t<form class=\"form-signin\" method=\"post\" action=\"\/upload\" enctype=\"multipart\/form-data\">\n\t\t\t\t\t<fieldset>\n\t\t\t\t\t\t<input type=\"file\" name=\"myfiles\" id=\"myfiles\" multiple=\"multiple\">\n\t\t\t\t\t\t<input type=\"submit\" name=\"submit\" value=\"Upload\">\n\t\t\t\t<\/fieldset>\n\t\t\t<\/form>\n\t\t<\/div>\n\t<\/body>\n<\/html>`\n","02-advanced - in_array":"package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\/\/ InArray will search element inside array with any type.\n\/\/ Will return boolean and index for matched element.\n\/\/ True and index more than 0 if element is exist.\n\/\/ needle is element to search, haystack is slice of value to be search.\nfunc InArray(needle interface{}, haystack interface{}) (exists bool, index int) {\n\texists = false\n\tindex = -1\n\n\tswitch reflect.TypeOf(haystack).Kind() {\n\tcase reflect.Slice:\n\t\ts := reflect.ValueOf(haystack)\n\n\t\tfor i := 0; i < s.Len(); i++ {\n\t\t\tif reflect.DeepEqual(needle, s.Index(i).Interface()) == true {\n\t\t\t\tindex = i\n\t\t\t\texists = true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc main() {\n\t\/\/ Array of string\n\tarrStrings := []string{\"foo\", \"bar\", \"baz\"}\n\tsearchString := \"bar\"\n\tstringExist, stringIndex := InArray(searchString, arrStrings)\n\tfmt.Printf(\"The '%s' is %v inside arrays %v with index: %d\\n\", searchString, stringExist, arrStrings, stringIndex)\n\n\t\/\/ Array of int64 (or you can use int or int32 too)\n\tarrInt64 := []int64{2016, 2017, 2018, 2019}\n\tsearchInt64 := int64(2016)\n\tint64Exist, int64Index := InArray(searchInt64, arrInt64)\n\tfmt.Printf(\"The '%d' is %v inside arrays %v with index: %d\\n\", searchInt64, int64Exist, arrInt64, int64Index)\n\n\t\/\/ Example for false searching\n\tint64NotExist := int64(2000)\n\tisElementExist, foundElementIndex := InArray(int64NotExist, arrInt64)\n\tfmt.Printf(\"The '%d' is %v inside arrays %v with index: %d\\n\", int64NotExist, isElementExist, arrInt64, foundElementIndex)\n\n\t\/\/ False searching with different type\n\t\/\/ Search string inside array of int64\n\tsearchStringInt64 := \"2018\"\n\tisStringExistInInt64Arr, stringIndexIn64ArrElement := InArray(searchStringInt64, arrInt64)\n\tfmt.Printf(\"The '%s' (%v) is %v inside arrays %v with index: %d\\n\", searchStringInt64, reflect.TypeOf(searchStringInt64).Name(), isStringExistInInt64Arr, arrInt64, stringIndexIn64ArrElement)\n\n\t\/\/ Or, you can also using array of interface\n\tarrInterface := []interface{}{\"username\", 123, int64(10), false}\n\tsearchElement := false\n\tok, index := InArray(searchElement, arrInterface)\n\tfmt.Printf(\"The '%v' is %v inside arrays %v with index: %d\\n\", searchElement, ok, arrInterface, index)\n}\n","02-advanced - interface":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc String(value interface{}) string {\n\tswitch val := value.(type) {\n\tcase bool:\n\t\tif value.(bool) == true {\n\t\t\treturn \"true\"\n\t\t}\n\t\treturn \"false\"\n\tcase time.Duration:\n\t\treturn string(val.String())\n\tcase time.Time:\n\t\treturn string(val.Format(time.RFC3339))\n\tcase string:\n\t\treturn val\n\tcase []byte:\n\t\treturn string(val)\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", val)\n\t}\n}\n\nfunc main() {\n\tfmt.Println(String(0x23))\n\tfmt.Println(String(0xfefe))\n\tfmt.Println(String(time.Minute * 5))\n\tfmt.Println(String(time.Now()))\n\tfmt.Println(String(false))\n}\n","02-advanced - iota":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Day int\n\nconst (\n\tSUNDAY Day = iota\n\tMONDAY\n\tTUESDAY\n\tWEDNESDAY\n\tTHURSDAY\n\tFRIDAY\n\tSATURDAY\n)\n\nfunc day() {\n\tfmt.Printf(\"Monday has the value %d\\n\", MONDAY)\n\tfmt.Printf(\"Friday has the value %d\\n\", FRIDAY)\n}\n\ntype Days int\n\nconst (\n\tSUNDAYS Days = 1 << iota\n\tMONDAYS\n\tTUESDAYS\n\tWEDNESDAYS\n\tTHURSDAYS\n\tFRIDAYS\n\tSATURDAYS\n)\n\nfunc days(d Days) {\n\tfmt.Print(\"\\nYou selected these days:\\n\")\n\n\tif d&SUNDAYS != 0 {\n\t\tfmt.Print(\"* SUNDAY\\n\")\n\t}\n\tif d&MONDAYS != 0 {\n\t\tfmt.Print(\"* MONDAY\\n\")\n\t}\n\tif d&TUESDAYS != 0 {\n\t\tfmt.Print(\"* TUESDAY\\n\")\n\t}\n\tif d&WEDNESDAYS != 0 {\n\t\tfmt.Print(\"* WEDNESDAY\\n\")\n\t}\n\tif d&THURSDAYS != 0 {\n\t\tfmt.Print(\"* THURSDAY\\n\")\n\t}\n\tif d&FRIDAYS != 0 {\n\t\tfmt.Print(\"* FRIDAY\\n\")\n\t}\n\tif d&SATURDAYS != 0 {\n\t\tfmt.Print(\"* SATURDAY\\n\")\n\t}\n}\n\nfunc main() {\n\tday()\n\n\tdays(34)\n\n\tdays(MONDAYS | FRIDAYS)\n\n\tdays(5)\n\n\tdays(127)\n}\n","02-advanced - json":"package main\n\nimport (\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\n\/\/var strings = []string{\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\"}\n\nfunc main() {\n\n\tvar strings []string\n\tvar jsonstring = `[\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\"]`\n\n\t\/\/convert json bytes-string to object\n\terr := json.Unmarshal([]byte(jsonstring), &strings)\n\n\tif err != nil {\n\t\tfmt.Println(\"error while unmarshalling\")\n\t\tos.Exit(2)\n\t}\n\n\tfmt.Println(strings)\n\n\t\/\/convert object to bytes-string\n\tjsonData, err := json.Marshal(strings)\n\n\tif err != nil {\n\t\tfmt.Println(\"error while marshalling\")\n\t\tos.Exit(2)\n\t}\n\n\tfmt.Println(string(jsonData))\n}\n","02-advanced - json2":"package main\n\nimport (\n\t\"bytes\"\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst jsonString = `\n\t[\n\t\t{\n\t\t\t\"type\": \"group\",\n\t\t\t\"value\": [\n\t\t\t\t\"Lorem\",\n\t\t\t\t\"Ipsum\",\n\t\t\t\t\"dolor\",\n\t\t\t\t\"sit\",\n\t\t\t\t\"Amet\"\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"value\",\n\t\t\t\"value\": \"Hello World\"\n\t\t},\n\t\t{\n\t\t\t\"type\": \"value\",\n\t\t\t\"value\": \"foobar\"\n\t\t}\n\t]\n`\n\ntype Codec interface {\n\tEncode(w io.Writer, v interface{}) error\n\tDecode(r io.Reader, v interface{}) error\n}\n\ntype jsonCodec struct{}\n\nfunc (*jsonCodec) Encode(w io.Writer, v interface{}) error {\n\treturn json.NewEncoder(w).Encode(v)\n}\nfunc (*jsonCodec) Decode(r io.Reader, v interface{}) error {\n\treturn json.NewDecoder(r).Decode(v)\n}\n\nfunc trimByte(str *bytes.Buffer) string {\n\treturn strings.TrimSpace(fmt.Sprint(str))\n}\n\nvar JSON Codec = (*jsonCodec)(nil)\n\nfunc main() {\n\tvar m interface{}\n\tvar b bytes.Buffer\n\n\tfmt.Printf(\"INPUT: %s\\n\", jsonString)\n\n\tif err := JSON.Decode(strings.NewReader(jsonString), &m); err == nil {\n\t\tfmt.Printf(\"DECODED: %#v\\n\", m)\n\t} else {\n\t\tfmt.Println(err)\n\t}\n\n\tif err := JSON.Encode(&b, &m); err == nil {\n\t\tfmt.Printf(\"ENCODED: %s\\n\", trimByte(&b))\n\t} else {\n\t\tfmt.Println(err)\n\t}\n}\n","02-advanced - json3":"package main\n\nimport (\n\t\"encoding\/json\"\n\t\"fmt\"\n)\n\nconst jsonString = `\n\t[\n\t\t{\n\t\t\t\"type\": \"group\",\n\t\t\t\"value\": [\n\t\t\t\t\"Lorem\",\n\t\t\t\t\"Ipsum\",\n\t\t\t\t\"dolor\",\n\t\t\t\t\"sit\",\n\t\t\t\t[\"A\", \"m\", \"e\", \"t\"]\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"type\": \"value\",\n\t\t\t\"value\": \"Hello World\"\n\t\t},\n\t\t{\n\t\t\t\"type\": \"value\",\n\t\t\t\"value\": \"foobar\"\n\t\t}\n\t]\n`\n\nfunc jsonforeach(in *interface{}, handler func(*string, *int, *interface{}, int)) {\n\teachJsonValue(in, handler, 0)\n}\n\nfunc eachJsonValue(node *interface{}, handler func(*string, *int, *interface{}, int), depth int) {\n\tif node == nil {\n\t\treturn\n\t}\n\to, isObject := (*node).(map[string]interface{})\n\tif isObject {\n\t\tfor k, v := range o {\n\t\t\thandler(&k, nil, &v, depth)\n\t\t\teachJsonValue(&v, handler, depth+1)\n\t\t}\n\t}\n\ta, isArray := (*node).([]interface{})\n\tif isArray {\n\t\tfor i, x := range a {\n\t\t\thandler(nil, &i, &x, depth)\n\t\t\teachJsonValue(&x, handler, depth+1)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tvar j interface{}\n\terr := json.Unmarshal([]byte(jsonString), &j)\n\tif err == nil {\n\t\tjsonforeach(&j, func(key *string, index *int, value *interface{}, depth int) {\n\t\t\tfor i := 0; i < depth; i++ {\n\t\t\t\tfmt.Print(\"  \")\n\t\t\t}\n\t\t\tv := *value\n\t\t\tswitch v.(type) {\n\t\t\tcase string:\n\t\t\t\tif key != nil {\n\t\t\t\t\tfmt.Printf(\"OBJECT: key=%q, value=%#v\\n\", *key, *value)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"ARRAY: index=%d, value=%#v\\n\", *index, *value)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif key != nil {\n\t\t\t\t\tfmt.Printf(\"%v\\n\", *key)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Println(\"\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t} else {\n\t\tfmt.Println(err)\n\t}\n}\n","02-advanced - lifo":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Lifo() *Stack {\n\treturn &Stack{}\n}\n\ntype Stack struct {\n\tnodes []string\n\tcount int\n}\n\nfunc (s *Stack) Push(n string) {\n\ts.nodes = append(s.nodes[:s.count], n)\n\ts.count++\n}\n\nfunc (s *Stack) Pop() string {\n\tif s.count == 0 {\n\t\treturn \"\"\n\t}\n\ts.count--\n\treturn s.nodes[s.count]\n}\n\nfunc main() {\n\tarray := Lifo()\n\tarray.Push(\"Amet\")\n\tarray.Push(\"ipsum\")\n\tarray.Push(\"Lorem\")\n\tfmt.Println(array.Pop())\n\tfmt.Println(array.Pop())\n\n\tarray.Push(\"sit\")\n\tarray.Push(\"Dolor\")\n\twhile := 1\n\tvalue := \"\"\n\tfor while > 0 {\n\t\tvalue = array.Pop()\n\t\tif value == \"\" {\n\t\t\twhile = 0\n\t\t} else {\n\t\t\tfmt.Println(value)\n\t\t}\n\t}\n}\n","02-advanced - log":"package main\n\nimport (\n\t\"log\"\n)\n\nfunc main() {\n\tlog.SetFlags(log.Ltime | log.Lshortfile)\n\n\tlog.Println(\"first log output\")\n\tlog.Printf(\"second log output\\n\")\n}\n","02-advanced - log2":"package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nvar (\n\tInfo    *log.Logger\n\tWarning *log.Logger\n\tError   *log.Logger\n)\n\nfunc LogInit(infoHandle, warningHandle, errorHandle io.Writer) {\n\n\tInfo = log.New(infoHandle,\n\t\t\"INFO: \",\n\t\tlog.Ltime|log.Lshortfile)\n\n\tWarning = log.New(warningHandle,\n\t\t\"WARNING: \",\n\t\tlog.Ltime|log.Lshortfile)\n\n\tError = log.New(errorHandle,\n\t\t\"ERROR: \",\n\t\tlog.Ldate|log.Ltime|log.Lshortfile)\n}\n\nfunc main() {\n\tLogInit(os.Stdout, os.Stderr, os.Stderr)\n\tInfo.Println(\"this is only a info message\")\n\tWarning.Println(\"you can print warnings the same way\")\n\tError.Println(\"and even errors work as expected\")\n\n\tprint(\"\\n\")\n\n\tInfo.Printf(`\n\t\tYou can do everything, a normal log.X command can do\n\t\tIn addition you can specify the output stream: stdout or stderr\n\t\tAnd define additional prefix und suffix strings.\n\t`)\n}\n","02-advanced - mandelbrot":"package main\n\nimport (\n\t\"image\"\n\t\"image\/color\"\n\t\"image\/png\"\n\t\"math\/cmplx\"\n\t\"os\"\n)\n\nfunc main() {\n\tconst (\n\t\txmin, ymin, xmax, ymax = -2, -2, +2, +2\n\t\twidth, height          = 1024, 1024\n\t)\n\n\timg := image.NewRGBA(image.Rect(0, 0, width, height))\n\tfor py := 0; py < height; py++ {\n\t\ty := float64(py)\/height*(ymax-ymin) + ymin\n\t\tfor px := 0; px < width; px++ {\n\t\t\tx := float64(px)\/width*(xmax-xmin) + xmin\n\t\t\tz := complex(x, y)\n\t\t\timg.Set(px, py, mandelbrot(z))\n\t\t}\n\t}\n\tpng.Encode(os.Stdout, img)\n}\n\nfunc mandelbrot(z complex128) color.Color {\n\tconst iterations = 200\n\tconst contrast = 15\n\n\tvar v complex128\n\tfor n := uint8(0); n < iterations; n++ {\n\t\tv = v*v + z\n\t\tif cmplx.Abs(v) > 2 {\n\t\t\treturn color.Gray{255 - contrast*n}\n\t\t}\n\t}\n\treturn color.Black\n}\n","02-advanced - map":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tmyMap := make(map[string]string)\n\n\t\/\/Insertionn in a map\n\tmyMap[\"A\"] = \"apple\"\n\tmyMap[\"B\"] = \"ball\"\n\tmyMap[\"C\"] = \"cat\"\n\n\t\/\/Traverse a map\n\tfmt.Println(\"Printing Map..........\")\n\tfor key, value := range myMap {\n\t\tfmt.Println(\"Key: \", key, \"  Value: \", value)\n\t}\n\n\t\/\/Delete a key-value pair from a map\n\t\/\/Deleting Key: \"C\" from map\n\tfmt.Println(\"Deleting a key from Map..........\")\n\tdelete(myMap, \"C\")\n\n\t\/\/Find the value associated with a key\n\tfmt.Println(\"Finding a key from Map..........\")\n\tfmt.Println(\"Value for key 'A': \", myMap[\"A\"])\n}\n","02-advanced - monkeypatching":"package main\n\nimport (\n\t\"fmt\"\n)\n\n\/\/ define the function as variable\nvar patchableFunc = func(i int) int {\n\treturn i * 2\n}\n\nfunc testFunc() {\n\t\/\/ save the original func\n\toriginalFunc := patchableFunc\n\n\t\/\/ restore the original func via defer at the end of the func\n\tdefer func() {\n\t\tpatchableFunc = originalFunc\n\t}()\n\n\t\/\/ call the function\n\tfmt.Println(patchableFunc(1))\n\n\t\/\/ change the function\n\tpatchableFunc = func(i int) int {\n\t\treturn i * 3\n\t}\n\n\t\/\/ call the function again\n\tfmt.Println(patchableFunc(2))\n}\n\nfunc main() {\n\tfmt.Println(patchableFunc(3))\n\ttestFunc()\n\tfmt.Println(patchableFunc(4))\n}\n","02-advanced - numbers":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc check(e error) {\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc main() {\n\tvar input string\n\tvar lstc1 string\n\tvar lstc2 int64\n\n\tif len(os.Args) >= 2 {\n\t\tinput = os.Args[1]\n\t} else {\n\t\tfmt.Println(\"Enter a number\")\n\t\t_, err1 := fmt.Scanf(\"%v\", &input)\n\t\tcheck(err1)\n\t}\n\n\tintin, err2 := strconv.ParseInt(input, 10, 0)\n\tcheck(err2)\n\n\tlstc1 = input[len(input)-1:]\n\tif intin >= 10 {\n\t\tlstc2, _ = strconv.ParseInt(input[len(input)-2:], 10, 0)\n\t} else {\n\t\tlstc2 = 0\n\t}\n\tlstc1 = input[len(input)-1:]\n\n\tswitch {\n\tcase lstc2 > 10 && lstc2 < 20:\n\t\tfmt.Printf(\"%vth\\n\", intin)\n\t\tbreak\n\tcase lstc1 == \"1\":\n\t\tfmt.Printf(\"%vst\\n\", intin)\n\t\tbreak\n\tcase lstc1 == \"2\":\n\t\tfmt.Printf(\"%vnd\\n\", intin)\n\t\tbreak\n\tcase lstc1 == \"3\":\n\t\tfmt.Printf(\"%vrd\\n\", intin)\n\t\tbreak\n\tdefault:\n\t\tfmt.Printf(\"%vth\\n\", intin)\n\t}\n}\n","02-advanced - oop":"package main\n\nimport \"fmt\"\nimport \"math\"\n\ntype geo interface {\n\tarea() float64\n\textent() float64\n\tvolume() float64\n}\n\ntype rectangle struct {\n\twidth, height float64\n}\n\ntype square struct {\n\tlength float64\n}\n\ntype circle struct {\n\tradius float64\n}\n\ntype cuboid struct {\n\twidth, height, length float64\n}\n\nfunc (r rectangle) area() float64 {\n\treturn r.width * r.height\n}\nfunc (r rectangle) extent() float64 {\n\treturn 2*r.width + 2*r.height\n}\n\nfunc (r rectangle) volume() float64 {\n\treturn 0\n}\n\nfunc (s square) area() float64 {\n\treturn s.length * s.length\n}\nfunc (s square) extent() float64 {\n\treturn 4 * s.length\n}\n\nfunc (s square) volume() float64 {\n\treturn 0\n}\n\nfunc (c circle) area() float64 {\n\treturn math.Pi * c.radius * c.radius\n}\n\nfunc (c circle) extent() float64 {\n\treturn math.Pi * (c.radius + c.radius)\n}\n\nfunc (c circle) volume() float64 {\n\treturn 0\n}\n\nfunc (c cuboid) area() float64 {\n\treturn 2 * (c.width*c.height + c.width*c.length + c.length*c.height)\n}\nfunc (c cuboid) extent() float64 {\n\treturn c.width*4 + c.height*4 + c.length*4\n}\nfunc (c cuboid) volume() float64 {\n\treturn c.width * c.height * c.length\n}\n\nfunc geocalc(g geo) {\n\tfmt.Printf(\"%#v\\t%#v\\t%#v\\t%#v\\n\", g, g.area(), g.extent(), g.volume())\n}\n\nfunc main() {\n\tr := rectangle{width: 2, height: 3}\n\ts := square{length: 3}\n\tc := circle{radius: 4}\n\tq := cuboid{width: 3, height: 2, length: 4}\n\n\tfmt.Printf(\"a rectangle with a width of %vm and a height of %vm has a area of %vm\u00b2 and a extent of %vm\\n\", r.width, r.height, r.area(), r.extent())\n\tfmt.Printf(\"a square with a side length of %vm has a area of %vm\u00b2 and a extent of %vm\\n\", s.length, s.area(), s.extent())\n\tfmt.Printf(\"a circle with a radius of %vm has a area of %vm\u00b2 and a extent of %vm\\n\", c.radius, c.area(), c.extent())\n\tfmt.Printf(\"a rectangular cuboid with a width of %vm, a height of %vm and a length of %vm has a area of %vm\u00b2 and a volume of %vm\u00b3\\n\", q.width, q.height, q.length, q.area(), q.volume())\n\n\tgeocalc(r)\n\tgeocalc(q)\n}\n","02-advanced - pipe":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n)\n\nfunc main() {\n\tvar regex string\n\tif len(os.Args) > 1 {\n\t\tregex = os.Args[1]\n\t} else {\n\t\tfmt.Fprintln(os.Stderr, \"pipe.go needs at least one parameter\")\n\t\tos.Exit(1)\n\t}\n\tpipe := bufio.NewScanner(os.Stdin)\n\n\tfor pipe.Scan() {\n\t\tstr := pipe.Text()\n\t\tmatched, _ := regexp.MatchString(regex, str)\n\t\tif matched {\n\t\t\tfmt.Println(str)\n\t\t}\n\t}\n\n\tif err := pipe.Err(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"error:\", err)\n\t\tos.Exit(1)\n\t}\n}\n","02-advanced - pointer":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc plusOne(in *int) {\n\t*in++\n}\n\nfunc main() {\n\tvar value int\n\tvalue = 5\n\n\tfmt.Printf(\"value: %v\\n\", value)\n\tplusOne(&value)\n\tfmt.Printf(\"value: %v\\n\", value)\n\tplusOne(&value)\n\tplusOne(&value)\n\tplusOne(&value)\n\tfmt.Printf(\"value: %v\\n\", value)\n}\n","02-advanced - pointerperformace":"package main\n\nimport (\n\t\"log\"\n\t\"time\"\n)\n\nfunc plusP(in *int) {\n\t*in = *in + 1\n}\n\nfunc plusPpp(in *int) {\n\t*in++\n}\n\nfunc plus(in int) int {\n\treturn in + 1\n}\n\nfunc main() {\n\tvar value int\n\tvar start time.Time\n\tvar elapsed time.Duration\n\n\tvalue = 5\n\n\tstart = time.Now()\n\n\tfor i := 0; i < 1600000; i++ {\n\t\tplusP(&value)\n\t}\n\n\telapsed = time.Since(start)\n\tlog.Printf(\"calculated %v with pointer took: %s\", value, elapsed)\n\n\tvalue = 5\n\n\tstart = time.Now()\n\n\tfor i := 0; i < 1600000; i++ {\n\t\tplusPpp(&value)\n\t}\n\n\telapsed = time.Since(start)\n\tlog.Printf(\"calculated %v with pointer (++) took: %s\", value, elapsed)\n\n\tvalue = 5\n\n\tstart = time.Now()\n\n\tfor i := 0; i < 1600000; i++ {\n\t\tvalue = plus(value)\n\t}\n\n\telapsed = time.Since(start)\n\tlog.Printf(\"calculated %v without pointer took: %s\", value, elapsed)\n}\n","02-advanced - prime":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc Sqrt(n int) int {\n\tvar t uint\n\tvar b uint\n\tvar r uint\n\tt = uint(n)\n\tp := uint(1 << 30)\n\tfor p > t {\n\t\tp >>= 2\n\t}\n\tfor ; p != 0; p >>= 2 {\n\t\tb = r | p\n\t\tr >>= 1\n\t\tif t >= b {\n\t\t\tt -= b\n\t\t\tr |= p\n\t\t}\n\t}\n\treturn int(r)\n}\n\nfunc getPrime(n int) int {\n\tvar primeList = []int{2}\n\tvar isPrime int = 1\n\tvar num int = 3\n\tvar sqrtNum int = 0\n\tfor len(primeList) < n {\n\t\tsqrtNum = Sqrt(num)\n\t\tfor i := 0; i < len(primeList); i++ {\n\t\t\tif num%primeList[i] == 0 {\n\t\t\t\tisPrime = 0\n\t\t\t}\n\t\t\tif primeList[i] > sqrtNum {\n\t\t\t\ti = len(primeList)\n\t\t\t}\n\t\t}\n\t\tif isPrime == 1 {\n\t\t\tprimeList = append(primeList, num)\n\t\t} else {\n\t\t\tisPrime = 1\n\t\t}\n\t\tnum = num + 2\n\t}\n\treturn primeList[n-1]\n}\n\nfunc main() {\n\tflag.Parse()\n\ts := flag.Arg(0)\n\ti, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tfmt.Println(\"please provide a number\")\n\t\tos.Exit(2)\n\t}\n\tfmt.Println(getPrime(i))\n}\n","02-advanced - pythagoras":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc q(a float64) float64 {\n\treturn a * a\n}\n\nfunc main() {\n\tif len(os.Args) == 4 {\n\t\tswitch \"?\" {\n\t\tcase os.Args[1]:\n\t\t\tb, _ := strconv.ParseFloat(os.Args[2], 0)\n\t\t\tc, _ := strconv.ParseFloat(os.Args[3], 0)\n\t\t\tfmt.Println(math.Sqrt(q(float64(c)) - q(float64(b))))\n\t\tcase os.Args[2]:\n\t\t\ta, _ := strconv.ParseFloat(os.Args[1], 0)\n\t\t\tc, _ := strconv.ParseFloat(os.Args[3], 0)\n\t\t\tfmt.Println(math.Sqrt(q(float64(c)) - q(float64(a))))\n\t\tcase os.Args[3]:\n\t\t\ta, _ := strconv.ParseFloat(os.Args[1], 0)\n\t\t\tb, _ := strconv.ParseFloat(os.Args[2], 0)\n\t\t\tfmt.Println(math.Sqrt(q(float64(a)) + q(float64(b))))\n\t\tdefault:\n\t\t\tfmt.Println(\"one of the arguments have to be a \\\"?\\\"\")\n\t\t}\n\t} else {\n\t\tfmt.Println(\"this app needs 3 arguments\")\n\t}\n}\n","02-advanced - regex":"package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nvar variable string\nvar strarray []string\nvar r = regexp.MustCompile(\"[^\\\\s]+\")\n\nfunc main() {\n\tvariable = \"Lorem  Ipsum  Dolor   Sit  Amet\"\n\tstrarray = r.FindAllString(variable, -1)\n\tfor i := 0; i < len(strarray); i++ {\n\t\tfmt.Println(strarray[i])\n\t}\n}\n","02-advanced - regex2":"package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\n\/*\nDate and time expressed according to ISO 8601:\n\nDate:\t\t\t\t\t\t\t2014-11-01\nCombined date and time in UTC:\t2014-11-01T10:01:13+00:00\n\t\t\t\t\t\t\t\t2014-11-01T10:01:13Z\nWeek:\t\t\t\t\t\t\t2014-W44\nDate with week number:\t\t\t2014-W44-6\nOrdinal date:\t\t\t\t\t2014-305\n*\/\n\nvar input string\nvar r = regexp.MustCompile(\"(?P<ISO8601>(?P<year>\\\\d{4})(\\\\-W((?P<week>\\\\d{1,2})\\\\-(?P<weekday>\\\\d)?)|\\\\-(?P<month>\\\\d{2})\\\\-(?P<day>\\\\d{2})(T(?P<hour>\\\\d{2}):(?P<min>\\\\d{2})(:(?P<sec>\\\\d{2})(\\\\+\\\\d{2}:\\\\d{2}Z?)?)?)?|\\\\-(?P<yearday>\\\\d{1,3})))\")\n\nfunc main() {\n\tinput = `\n2014-06-06\n2014-11-01\n2014-11-01T10:01:13+00:00\n2014-11-01T10:01:13Z\n2014-W44\n2014-W44-6\n2014-305\n2014-23\n`\n\tmatch := r.FindAllString(input, -1)\n\tfor i := 0; i < len(match); i++ {\n\t\tsubmatch := r.FindStringSubmatch(match[i])\n\t\tfmt.Printf(\"\\nInput: %#v\\n\", match[i])\n\t\tfor i, name := range r.SubexpNames() {\n\t\t\tif name != \"\" && submatch[i] != \"\" {\n\t\t\t\tfmt.Printf(\"\\t%s\\t %s\\n\", name, submatch[i])\n\t\t\t}\n\t\t}\n\t}\n}\n","02-advanced - reuseport":"package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net\/http\"\n\t\"os\"\n\t\"syscall\"\n)\n\nvar listenConfig = net.ListenConfig{\n\tControl: func(network, address string, c syscall.RawConn) error {\n\t\tvar opErr error\n\t\tif err := c.Control(func(fd uintptr) {\n\t\t\topErr = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn opErr\n\t},\n}\n\nfunc main() {\n\tpid := os.Getpid()\n\tlistener, err := listenConfig.Listen(context.Background(), \"tcp\", \"127.0.0.1:8080\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tserver := &http.Server{}\n\thttp.HandleFunc(\"\/\", func(rw http.ResponseWriter, req *http.Request) {\n\t\trw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(rw, \"Hello from PID %d \\n\", pid)\n\t\tfmt.Printf(\"serving to %v (%v) with PID %d \\n\", req.RemoteAddr, req.Header.Get(\"X-Forwarded-For\"), pid)\n\t})\n\tfmt.Printf(\"HTTP Server with PID %d is running \\n\", pid)\n\n\tpanic(server.Serve(listener))\n}\n","02-advanced - runtime":"package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"runtime\"\n\t\"time\"\n)\n\nfunc Debug(format string, a ...interface{}) {\n\t_, file, line, _ := runtime.Caller(1)\n\tinfo := fmt.Sprintf(format, a...)\n\n\tlog.Printf(\"%s:%d %v\", file, line, info)\n}\n\nfunc foobar(format string, a ...interface{}) {\n\tDebug(format, a)\n}\n\nfunc main() {\n\tfoobar(\"test: %v\\n\", time.Now())\n}\n","02-advanced - suicide":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os\/exec\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tpid := os.Getpid()\n\tstr := strconv.Itoa(pid)\n\tfmt.Println(\"Process identifier: \", str)\n\tret, _ := exec.Command(\"kill\", \"-9\", str).Output()\n\tfmt.Println(\"this will never be printed: \", ret)\n}\n","02-advanced - template":"package main\n\nimport (\n\t\"encoding\/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"text\/template\"\n\t\"time\"\n)\n\ntype Person []struct {\n\tName struct {\n\t\tTitle  string `json:\"title\"`\n\t\tFirst  string `json:\"first\"`\n\t\tMiddle string `json:\"middle\"`\n\t\tLast   string `json:\"last\"`\n\t} `json:\"name\"`\n\tAddress struct {\n\t\tStreet   string `json:\"street\"`\n\t\tZip      string `json:\"zip\"`\n\t\tLocation string `json:\"location\"`\n\t\tCountry  string `json:\"country\"`\n\t} `json:\"address\"`\n\tContact struct {\n\t\tPhone  string `json:\"phone\"`\n\t\tMobile string `json:\"mobile\"`\n\t\tEmail  string `json:\"email\"`\n\t\tWeb    string `json:\"web\"`\n\t} `json:\"contact\"`\n\tGender   string `json:\"gender\"`\n\tBirthday string `json:\"birthday\"`\n}\n\nfunc shortMiddleName(input string) string {\n\tif len(input) > 0 {\n\t\treturn input[0:1] + \".\"\n\t}\n\treturn \"\"\n}\n\nfunc getDate() string {\n\treturn time.Now().Format(\"2006-01-02\")\n}\n\nfunc main() {\n\tjsonstr, latexstr := getExampleData()\n\n\tperson := Person{}\n\n\terr := json.Unmarshal([]byte(jsonstr), &person)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfmap := template.FuncMap{\n\t\t\"shortMiddleName\": shortMiddleName,\n\t\t\"getDate\":         getDate,\n\t\t\"getPlace\": func() string {\n\t\t\treturn \"Munich\"\n\t\t},\n\t}\n\n\tt := template.New(\"letter\").Delims(\"<<\", \">>\").Funcs(fmap)\n\n\t_, err = t.Parse(latexstr)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tf, err := os.OpenFile(\".\/template_latex.tex\", os.O_WRONLY|os.O_CREATE, 0755)\n\tif err == nil {\n\t\terr = t.Execute(f, person)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t\treturn\n\t}\n\tfmt.Println(err)\n\tt.Execute(os.Stdout, person)\n}\n\nfunc getExampleData() (string, string) {\n\tjsonstr := `\n[\n  {\n    \"Name\": {\n      \"Title\": \"Dr.\",\n      \"First\": \"John\",\n      \"Middle\": \"F.\",\n      \"Last\": \"Doe\"\n    },\n    \"Address\": {\n      \"Street\": \"Musterweg 2\",\n      \"Zip\": \"12345\",\n      \"Location\": \"Bielefeld\",\n      \"Country\": \"Germany\"\n    },\n    \"Gender\": \"m\",\n    \"Birthday\": \"1970-01-01\"\n  },\n  {\n    \"Name\": {\n      \"Title\": \"Prof. Dr.\",\n      \"First\": \"Jane\",\n      \"Middle\": \"A.\",\n      \"Last\": \"Doe\"\n    },\n    \"Address\": {\n      \"Street\": \"Musterweg 3\",\n      \"Zip\": \"12345\",\n      \"Location\": \"Bielefeld\",\n      \"Country\": \"Germany\"\n    },\n    \"Gender\": \"f\",\n    \"Birthday\": \"1980-01-03\"\n  },\n  {\n    \"Name\": {\n      \"Title\": \"Dr.\",\n      \"First\": \"Sascha\",\n      \"Middle\": \"\",\n      \"Last\": \"Doe\"\n    },\n    \"Address\": {\n      \"Street\": \"Musterweg 4\",\n      \"Zip\": \"12345\",\n      \"Location\": \"Bielefeld\",\n      \"Country\": \"Germany\"\n    },\n    \"Gender\": \"d\",\n    \"Birthday\": \"1978-01-02\"\n  }\n]`\n\tlatexstr := `\n\\documentclass[\n    sender,\n    paper=a4,\n    version=last,\n    fontsize=12pt,\n    DIV=13,\n    BCOR=0mm]{scrlttr2}\n\\parskip4mm\n\\parindent0mm\n\\usepackage[english,ngerman]{babel}\n\\usepackage[utf8]{inputenc}\n\\usepackage{csquotes}\n\n\\usepackage{lmodern}\n\\renewcommand*\\familydefault{\\sfdefault}\n\\usepackage[T1]{fontenc}\n\n\\usepackage{changepage}\n\\changepage{+3cm}{}{}{}{}{}{}{}{-5cm}\n\\LoadLetterOption{sender}\n\n\\begin{document}\n<< range . >>\n\\newpage\n\\setkomavar*{enclseparator}{Appendix}\n\\setkomavar{subject}{Subject: This is an Example}\n\\setkomavar{date}{<< getDate >>}\n\\setkomavar{place}{<< getPlace >>}\n\n\\begin{letter}{\n    << .Name.Title >> << .Name.First >> << .Name.Middle | shortMiddleName >> << .Name.Last >> \\\\\n    << .Address.Street >>\\\\\n    << .Address.Zip >> << .Address.Location >>\n}\n\\opening{Dear Recipient}\n\n\\selectlanguage{english}\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. \n\n\\closing{kind regards}\n<< end >>\n\\end{letter}\n\n\\end{document}\n`\n\n\treturn jsonstr, latexstr\n}\n","02-advanced - ticker":"package main\n\nimport (\n\t\"crypto\/rand\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc getrandom() int {\n\tb := make([]byte, 2)\n\trand.Read(b)\n\tnumber := uint32(b[0]) | (uint32(b[1]) << 8)\n\treturn int(number)\n}\n\nfunc main() {\n\tvar x int\n\tticker := time.NewTicker(time.Millisecond * 500)\n\tgo func() {\n\t\tfor t := range ticker.C {\n\t\t\tfmt.Printf(\"ticker:\\t%d\\tat:\\t\", x)\n\t\t\tfmt.Println(t)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tx = getrandom()\n\t\t}\n\t}()\n\n\ttime.Sleep(time.Second * 10)\n\tticker.Stop()\n\tfmt.Println(\"Ticker stopped\")\n}\n","02-advanced - timeout":"package main\n\nimport (\n\t\"crypto\/rand\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc getrandom() int {\n\tb := make([]byte, 3)\n\trand.Read(b)\n\tnumber := uint32(b[0]) | (uint32(b[1]) << 8) | (uint32(b[2]) << 16)\n\treturn int(number)\n}\n\nfunc randomcalculate(i int) int {\n\tvar r, x int\n\tfor a := 0; a < 1000; a++ {\n\t\tr = getrandom() \/ 1337\n\t\tx = (i + r) \/ 42\n\t\tfmt.Printf(\"%d\\t+\\t%d\\t=\\t%d\\n\", i, r, x)\n\t\ti = x\n\t\ttime.Sleep(15 * time.Millisecond)\n\t}\n\treturn i\n}\n\nfunc main() {\n\tchanx := make(chan int)\n\tgo func() {\n\t\tchanx <- randomcalculate(6)\n\t}()\n\tselect {\n\tcase res := <-chanx:\n\t\tfmt.Println(res)\n\tcase <-time.After(time.Millisecond * 150):\n\t\tfmt.Println(\"timeout\")\n\t}\n\n}\n","02-advanced - wait":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc f(w *sync.WaitGroup, sec int) {\n\tfmt.Println(\"a\")\n\ttime.Sleep(time.Duration(sec) * time.Second)\n\tfmt.Println(\"b\")\n\tw.Done()\n}\n\nfunc main() {\n\tfmt.Println(\"start\")\n\tvar w sync.WaitGroup\n\tw.Add(2)\n\n\tgo func(w *sync.WaitGroup, sec int) {\n\t\tfmt.Println(\"c\")\n\t\t<-time.After(time.Duration(sec) * time.Millisecond)\n\t\tfmt.Println(\"d\")\n\t\tw.Done()\n\t}(&w, 2500)\n\n\tgo f(&w, 4)\n\n\tw.Wait()\n\n\ttime.Sleep(900000000 * time.Nanosecond)\n\n\tfmt.Println(\"finish\")\n}\n","02-advanced - wordsearch":"package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n\/\/ WordSearch is solution for word search problem\n\/\/ Given a 2D board and a word, find if the word exists in the grid.\n\/\/\n\/\/ The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\/\/\n\/\/ For example,\n\/\/ Given board =\n\/\/\n\/\/ [\n\/\/\n\/\/\t['A','B','C','E'],\n\/\/\t['S','F','C','S'],\n\/\/\t['A','D','E','E']\n\/\/\n\/\/ ]\n\/\/ word = \"ABCCED\", -> returns true,\n\/\/ word = \"SEE\", -> returns true,\n\/\/ word = \"ABCB\", -> returns false.\ntype WordSearch struct {\n\tboard [][]byte\n}\n\n\/\/ Exist is for checking existing word within boards\nfunc (w *WordSearch) Exist(word string) bool {\n\tfor i, h := range w.board {\n\t\tfor j := range h {\n\t\t\tif w.dfs(w.board, word, i, j) == true {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n\/\/ dfs deep first search\nfunc (w *WordSearch) dfs(board [][]byte, word string, i, j int) bool {\n\t\/\/fmt.Println(board)\n\tif len(word) == 0 {\n\t\treturn true\n\t}\n\n\tif i < 0 ||\n\t\ti >= len(board) ||\n\t\tj < 0 ||\n\t\tj >= len(board[0]) ||\n\t\tboard[i][j] != word[0] {\n\t\treturn false\n\t}\n\t\/\/fmt.Println(board, word, i, j, len(board),len(board[0]), board[i][j]!=word[0], word[0], word[1:], board[i][j]  )\n\ttmp := board[i][j]\n\tboard[i][j] = '#'\n\tresult := w.dfs(board, word[1:], i+1, j) ||\n\t\tw.dfs(board, word[1:], i-1, j) ||\n\t\tw.dfs(board, word[1:], i, j+1) ||\n\t\tw.dfs(board, word[1:], i, j-1)\n\tboard[i][j] = tmp\n\treturn result\n}\n\n\/\/ NewWordSearch for create new instance wordsearch\nfunc NewWordSearch(board [][]byte) *WordSearch {\n\treturn &WordSearch{\n\t\tboard: board,\n\t}\n}\n\n\/\/ FindWords to find words from boards\n\/\/ Given a 2D board and a list of words from the dictionary, find all words in the board.\n\/\/ Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\/\/ For example,\n\/\/ Given words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board =\n\/\/ [\n\/\/\n\/\/\t['o','a','a','n'],\n\/\/\t['e','t','a','e'],\n\/\/\t['i','h','k','r'],\n\/\/\t['i','f','l','v']\n\/\/\n\/\/ ]\n\/\/ Return [\"eat\",\"oath\"].\n\/\/ Note:\n\/\/ You may assume that all inputs are consist of lowercase letters a-z.\n\/\/ You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?\n\/\/ If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.\nfunc (w *WordSearch) FindWords(words []string) []string {\n\twords = removeDuplicates(words)\n\tsort.Strings(words)\n\tvar results = []string{}\n\tfor _, word := range words {\n\t\tif w.Exist(word) {\n\t\t\tresults = append(results, word)\n\t\t}\n\t}\n\n\treturn results\n}\n\nfunc removeDuplicates(elements []string) []string {\n\t\/\/ Use map to record duplicates as we find them.\n\tencountered := map[string]bool{}\n\tresult := []string{}\n\n\tfor v := range elements {\n\t\tif encountered[elements[v]] == true {\n\t\t\t\/\/ Do not add duplicate.\n\t\t} else {\n\t\t\t\/\/ Record this element as an encountered element.\n\t\t\tencountered[elements[v]] = true\n\t\t\t\/\/ Append to result slice.\n\t\t\tresult = append(result, elements[v])\n\t\t}\n\t}\n\t\/\/ Return the new slice.\n\treturn result\n}\n\nfunc main() {\n\n\tboard := [][]byte{\n\t\t[]byte(\"CAA\"),\n\t\t[]byte(\"AAA\"),\n\t\t[]byte(\"BCD\"),\n\t}\n\n\tnws := NewWordSearch(board)\n\tfmt.Println(nws.Exist(\"AAB\")) \/\/ true\n\n\tboard2 := [][]byte{\n\t\t[]byte(\"oaan\"),\n\t\t[]byte(\"etae\"),\n\t\t[]byte(\"ihkr\"),\n\t\t[]byte(\"ihkr\"),\n\t}\n\n\tnws2 := NewWordSearch(board2)\n\twords := []string{\"oath\", \"pea\", \"eat\", \"rain\"}\n\n\tfmt.Println(nws2.FindWords(words)) \/\/ \"eat\", \"oath\n\n}\n","02-advanced - xml":"package main\n\nimport (\n\t\"encoding\/xml\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc (c *classAccessesMap) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tc.Map = map[string]string{}\n\tval := \"\"\n\n\tfor {\n\t\tt, _ := d.Token()\n\t\tswitch tt := t.(type) {\n\n\t\tcase xml.StartElement:\n\n\t\tcase xml.EndElement:\n\t\t\tif tt.Name == start.Name {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tc.Map[tt.Name.Local] = val\n\t\tdefault:\n\t\t\tval = strings.TrimSpace(fmt.Sprintf(\"%s\", tt))\n\t\t}\n\t}\n}\n\nfunc ParseDocumentXML(xmlString string) Variables {\n\tm := Variables{}\n\txml.Unmarshal([]byte(xmlString), &m)\n\treturn m\n}\n\ntype Variables struct {\n\tHead Head\n\tData classAccessesMap `xml:\"Data\"`\n}\n\ntype Head struct {\n\tName string\n\tIP   string\n}\n\ntype classAccessesMap struct {\n\tMap map[string]string\n}\n\nfunc main() {\n\ttxt := `\n        <Variables>\n       <Head>\n           <Name>WKS001<\/Name>\n           <IP>192.168.178.23<\/IP>\n       <\/Head>\n       <Data>\n           <POSNR>10<\/POSNR>\n           <AUFNR>103002<\/AUFNR>\n           <KUNNR>332401<\/KUNNR>\n           <ZTXT1>lorem<\/ZTXT1>\n           <ZTXT2>ipsum<\/ZTXT2>\n           <ZTXT3>dolor<\/ZTXT3>\n           <ZTXT4>sit a<\/ZTXT4>\n       <\/Data>\n    <\/Variables>\n        `\n\tm := Variables{}\n\txml.Unmarshal([]byte(txt), &m)\n\n\tfmt.Printf(\"xml: %#v\\n\", m)\n\tfor a, b := range m.Data.Map {\n\t\tfmt.Printf(\"key: %s, value: %s\\n\", a, b)\n\t}\n}\n","02-advanced - zip":"package main\n\nimport (\n\t\"archive\/zip\"\n\t\"fmt\"\n\t\"io\"\n\t\"io\/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path\/filepath\"\n\t\"strings\"\n)\n\nfunc ZipContent(file string) []string {\n\tvar filenames []string\n\tarchive, err := zip.OpenReader(file)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer archive.Close()\n\n\tfor _, f := range archive.File {\n\t\tif f.Name[0:1] == \".\" {\n\t\t\t\/\/hide hidden files\n\t\t\tcontinue\n\t\t}\n\t\tfilenames = append(filenames, f.Name)\n\t}\n\treturn filenames\n}\n\nfunc UnzipAll(file string, dest string) {\n\tarchive, err := zip.OpenReader(file)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer archive.Close()\n\n\tfor _, f := range archive.File {\n\t\tfilePath := filepath.Join(dest, f.Name)\n\t\tfmt.Println(\"unzipping file \", filePath)\n\n\t\tif !strings.HasPrefix(filePath, filepath.Clean(dest)+string(os.PathSeparator)) {\n\t\t\tfmt.Println(\"invalid file path\")\n\t\t\treturn\n\t\t}\n\t\tif f.FileInfo().IsDir() {\n\t\t\tfmt.Println(\"creating directory...\")\n\t\t\tos.MkdirAll(filePath, os.ModePerm)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdstFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer dstFile.Close()\n\n\t\tfileInArchive, err := f.Open()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tdefer fileInArchive.Close()\n\n\t\tif _, err := io.Copy(dstFile, fileInArchive); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t}\n}\n\nfunc ReadZipped(zipFile, file string) string {\n\tarchive, err := zip.OpenReader(zipFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer archive.Close()\n\n\tfor _, f := range archive.File {\n\t\tif f.Name != file {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileInArchive, err := f.Open()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer fileInArchive.Close()\n\n\t\tdata, err := ioutil.ReadAll(fileInArchive)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\treturn string(data)\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\tfiles := ZipContent(\"example.zip\")\n\n\tfmt.Printf(\"%#v\\n\", files)\n\n\tcontent := ReadZipped(\"example.zip\", files[2])\n\tfmt.Printf(\"%#v\\n\", content)\n\n\tUnzipAll(\"example.zip\", \"output\")\n}\n","03-expert - assembly":"package main\n\nimport (\n\tassembly \".\/assembly\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tfmt.Println(assembly.Add(32, 64))\n}\n","03-expert - cgo":"package main\n\n\/*\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid print(char* s) {\n\tprintf(\"%s\", s);\n}\n\nlong factorial(int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t} else {\n\t\treturn (n * factorial(n - 1));\n\t}\n}\n\nlong gcd(long a, long b) {\n\tif (b == 0) {\n\t\treturn a;\n\t} else {\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nvoid prime(int n) {\n\tint i = 0, count, c;\n\tfor (count = 2; count <= n + 1; ) {\n\t\tfor (c = 2; c <= i - 1; c++ ) {\n\t\t\tif (i % c == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (c == i) {\n\t\t\tprintf(\"%d \", i);\n\t\t\tcount++;\n\t\t}\n\t\ti++;\n\t}\n\tprint(\"\\n\");\n}\n\nint fibonacci(int n) {\n\tif (n == 0) {\n\t\treturn 0;\n\t} else if (n == 1) {\n\t\treturn 1;\n\t} else {\n\t\treturn (fibonacci(n - 1) + fibonacci(n - 2));\n\t}\n}\n\n*\/\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\nfunc main() {\n\tfmt.Print(\"C.print: \")\n\tcs := C.CString(\"Hello from cgo\\n\")\n\tC.print(cs)\n\tC.free(unsafe.Pointer(cs))\n\n\tfmt.Print(\"C.factorial: \")\n\tfmt.Println(C.factorial(5))\n\n\tfmt.Print(\"C.gcd: \")\n\tfmt.Println(C.gcd(15, 230))\n\n\tfmt.Print(\"C.prime: \")\n\tC.prime(6)\n\n\tfmt.Print(\"C.fibonacci: \")\n\tfmt.Println(C.fibonacci(5))\n}\n","03-expert - codegen":"package main\n\nimport (\n\t\"encoding\/json\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"text\/template\"\n)\n\n\/\/go:generate go run codegen.go\n\/\/go:generate go fmt codegenerated\/codegenerated.go\n\ntype Struct struct {\n\tName   string\n\tFields map[string]interface{}\n}\n\nfunc title(input string) string {\n\tinput = strings.Replace(input, \"_\", \" \", -1)\n\tinput = strings.Title(input)\n\tinput = strings.Replace(input, \" \", \"\", -1)\n\treturn input\n}\n\nfunc typeOf(v interface{}) string {\n\tif v == nil {\n\t\treturn \"string\"\n\t}\n\treturn strings.ToLower(reflect.TypeOf(v).String())\n}\n\nfunc genStructCode() {\n\ttemplateString, jsonString := getExampleData()\n\n\tvar resp map[string]interface{}\n\tjson.Unmarshal([]byte(jsonString), &resp)\n\n\tdata := Struct{\"Data\", resp}\n\n\ttpl, _ := template.New(\"struct\").Funcs(template.FuncMap{\n\t\t\"Title\":  title,\n\t\t\"TypeOf\": typeOf,\n\t}).Parse(templateString)\n\n\tout, _ := os.Create(\"codegenerated\/codegenerated.go\")\n\tdefer out.Close()\n\n\ttpl.Execute(out, data)\n}\n\nfunc main() {\n\tgenStructCode()\n}\n\nfunc getExampleData() (string, string) {\n\ttemplateString := `\npackage codegen\n\ntype {{ .Name | Title }} struct {\n{{ range $jsonName, $val := .Fields }}\n    {{- $jsonName | Title }} {{ $val | TypeOf }} ` + \"`\" + `json:\"{{ $jsonName }}\"` + \"`\" + `\n{{ end }}\n}\n`\n\n\tjsonString := `\n{\n  \"lorem\": \"ipsum\",\n  \"dolor\": \"sit\",\n  \"amet\": 1337,\n  \"foo_bar\": true,\n  \"bar\": false\n}\n`\n\treturn templateString, jsonString\n}\n","03-expert - color":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc rgb2hsl(r int, g int, b int) (int, int, int) {\n\tvar rf, gf, bf, max, min, l, d, s, h float64\n\n\trf = math.Max(math.Min(float64(r)\/255, 1), 0)\n\tgf = math.Max(math.Min(float64(g)\/255, 1), 0)\n\tbf = math.Max(math.Min(float64(b)\/255, 1), 0)\n\tmax = math.Max(rf, math.Max(gf, bf))\n\tmin = math.Min(rf, math.Min(gf, bf))\n\tl = (max + min) \/ 2\n\n\tif max != min {\n\t\td = max - min\n\t\tif l > 0.5 {\n\t\t\ts = d \/ (2 - max - min)\n\t\t} else {\n\t\t\ts = d \/ (max + min)\n\t\t}\n\t\tif max == rf {\n\t\t\tif gf < bf {\n\t\t\t\th = (gf-bf)\/d + 6\n\t\t\t} else {\n\t\t\t\th = (gf - bf) \/ d\n\t\t\t}\n\t\t} else if max == gf {\n\t\t\th = (bf-rf)\/d + 2\n\t\t} else {\n\t\t\th = (rf-gf)\/d + 4\n\t\t}\n\t} else {\n\t\th = 0\n\t\ts = 0\n\t}\n\n\treturn int(h * 60), int(s * 100), int(l * 100)\n}\n\nfunc main() {\n\tfmt.Println(rgb2hsl(121, 167, 22))\n\tfmt.Println(rgb2hsl(69, 209, 237))\n\tfmt.Println(rgb2hsl(254, 207, 37))\n\tfmt.Println(rgb2hsl(122, 167, 255))\n\tfmt.Println(rgb2hsl(255, 255, 255))\n}\n","03-expert - cookies":"package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n\tc, err := r.Cookie(\"timestamp\")\n\tcookie := &http.Cookie{\n\t\tName:  \"timestamp\",\n\t\tValue: strconv.FormatInt(time.Now().Unix(), 10),\n\t}\n\thttp.SetCookie(w, cookie)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tfmt.Fprintf(w, \"Hello, you're here for the first time\")\n\t} else {\n\t\ttimeint, _ := strconv.ParseInt(c.Value, 10, 0)\n\t\tfmt.Fprintf(w, \"Hi, your last visit was at \"+time.Unix(timeint, 0).Format(\"15:04:05\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"\/\", rootHandler)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n","03-expert - dynparallel":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\/rand\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"time\"\n)\n\nfunc check(e error) {\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc Sqrt(n int) int {\n\tvar t uint\n\tvar b uint\n\tvar r uint\n\tt = uint(n)\n\tp := uint(1 << 30)\n\tfor p > t {\n\t\tp >>= 2\n\t}\n\tfor ; p != 0; p >>= 2 {\n\t\tb = r | p\n\t\tr >>= 1\n\t\tif t >= b {\n\t\t\tt -= b\n\t\t\tr |= p\n\t\t}\n\t}\n\treturn int(r)\n}\n\nfunc getPrime(n int) int {\n\tvar primeList = []int{2}\n\tvar isPrime int = 1\n\tvar num int = 3\n\tvar sqrtNum int = 0\n\tfor len(primeList) < n {\n\t\tsqrtNum = Sqrt(num)\n\t\tfor i := 0; i < len(primeList); i++ {\n\t\t\tif num%primeList[i] == 0 {\n\t\t\t\tisPrime = 0\n\t\t\t}\n\t\t\tif primeList[i] > sqrtNum {\n\t\t\t\ti = len(primeList)\n\t\t\t}\n\t\t}\n\t\tif isPrime == 1 {\n\t\t\tprimeList = append(primeList, num)\n\t\t} else {\n\t\t\tisPrime = 1\n\t\t}\n\t\tnum = num + 2\n\t}\n\treturn primeList[n-1]\n}\n\nfunc enNmbr(input string) string {\n\tvar lstc1 string\n\tvar lstc2 int64\n\tintin, err2 := strconv.ParseInt(input, 10, 0)\n\tcheck(err2)\n\n\tlstc1 = input[len(input)-1:]\n\tif intin >= 10 {\n\t\tlstc2, _ = strconv.ParseInt(input[len(input)-2:], 10, 0)\n\t} else {\n\t\tlstc2 = 0\n\t}\n\tlstc1 = input[len(input)-1:]\n\n\tswitch {\n\tcase lstc2 > 10 && lstc2 < 20:\n\t\treturn input + \"th\"\n\tcase lstc1 == \"1\":\n\t\treturn input + \"st\"\n\tcase lstc1 == \"2\":\n\t\treturn input + \"nd\"\n\tcase lstc1 == \"3\":\n\t\treturn input + \"rd\"\n\tdefault:\n\t\treturn input + \"th\"\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\tvar nprocs int\n\tif len(os.Args) >= 2 {\n\t\tnprocs, _ = strconv.Atoi(os.Args[1])\n\t} else {\n\t\tfmt.Println(\"Enter a number\")\n\t\t_, err1 := fmt.Scanf(\"%d\", &nprocs)\n\t\tcheck(err1)\n\t}\n\tif nprocs < 2 {\n\t\tpanic(\"input to low\")\n\t}\n\n\tfmt.Println(\"setting max processes to: \", nprocs)\n\truntime.GOMAXPROCS(nprocs)\n\n\tvar prime int\n\tvar random int\n\tchannels := make([]chan int, nprocs)\n\tfor i := 0; i < nprocs; i++ {\n\t\tchannels[i] = make(chan int)\n\t}\n\n\tfor i := 0; i < nprocs; i++ {\n\t\trand.Seed(time.Now().UnixNano() + int64(i))\n\t\trandom = rand.Intn(6400) + 1\n\t\tfmt.Printf(\"sending request for the %v prime number on channel %v\\n\", enNmbr(strconv.Itoa(random)), i)\n\t\tgo func(ch chan int, random int, i int) {\n\t\t\ttime.Sleep(time.Duration(random) * time.Millisecond)\n\t\t\tfmt.Printf(\"calculating the %v prime number for channel %v\\n\", enNmbr(strconv.Itoa(random)), i)\n\t\t\tprime = getPrime(random)\n\t\t\tch <- prime\n\t\t}(channels[i], random, i)\n\t}\n\n\tvar chancount int = 0\n\tfor {\n\t\tfor i := 0; i < nprocs; i++ {\n\t\t\tselect {\n\t\t\tcase v := <-channels[i]:\n\t\t\t\tfmt.Printf(\"received %v from channel %v\\n\", v, i)\n\t\t\t\tchancount++\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tif chancount == nprocs {\n\t\t\tbreak\n\t\t}\n\n\t}\n}\n","03-expert - explorer":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n)\n\nfunc main() {\n\twd, err := os.Getwd()\n\tif err == nil {\n\t\tfmt.Println(wd)\n\t\tfiles, _ := ioutil.ReadDir(wd)\n\t\tfor _, f := range files {\n\t\t\tfmt.Printf(\"-> %v\\n\", f.Name())\n\t\t}\n\t}\n}\n","03-expert - generics":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Number interface {\n\tint64 | float64\n}\n\nfunc SumInts(m ...int64) int64 {\n\tvar s int64\n\tfor _, v := range m {\n\t\ts += v\n\t}\n\treturn s\n}\n\nfunc SumFloats(m ...float64) float64 {\n\tvar s float64\n\tfor _, v := range m {\n\t\ts += v\n\t}\n\treturn s\n}\n\nfunc SumIntsOrFloats[V int64 | float64](m ...V) V {\n\tvar s V\n\tfor _, v := range m {\n\t\ts += v\n\t}\n\treturn s\n}\n\nfunc SumNumbers[V Number](m ...V) V {\n\tvar s V\n\tfor _, v := range m {\n\t\ts += v\n\t}\n\treturn s\n}\n\nfunc main() {\n\tints := []int64{31, 37, 41, 43, 47, 53, 59}\n\tfloats := []float64{31.17, 37.2, 41.9, 43.002, 47, 53, 59}\n\n\tfmt.Printf(\"Non-Generic Sums: %v and %v\\n\",\n\t\tSumInts(ints...),\n\t\tSumFloats(floats...))\n\n\tfmt.Printf(\"Generic Sums: %v and %v\\n\",\n\t\tSumIntsOrFloats(ints...),\n\t\tSumIntsOrFloats(floats...))\n\n\tfmt.Printf(\"Generic Sums: %v and %v\\n\",\n\t\tSumNumbers(ints...),\n\t\tSumNumbers(floats...))\n}\n","03-expert - gocomment":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"os\/exec\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tif len(os.Args) >= 2 {\n\t\tvar output string\n\t\tvar i int\n\t\tinput := os.Args[1]\n\t\tgosrcs, _ := ioutil.ReadFile(input)\n\t\tgosrc := string(gosrcs)\n\t\tgorun, _ := exec.Command(\"go\", \"build\", input).Output()\n\t\tgostr := string(gorun)\n\t\taline := regexp.MustCompile(\"[^\\\\n]*\\\\n\")\n\t\tline, _ := regexp.Compile(input + \":(\\\\d+): \")\n\t\tstre := line.FindAllStringSubmatch(gostr, -1)\n\t\tstra := aline.FindAllString(gosrc, -1)\n\t\tj := 0\n\t\tfor i = 0; i < len(stra); i++ {\n\t\t\tif len(stre) > j {\n\t\t\t\tlc, _ := strconv.ParseInt(stre[j][1], 10, 0)\n\t\t\t\tif i == int(lc)-1 {\n\t\t\t\t\toutput += \"\/\/\" + stra[i]\n\t\t\t\t\tj++\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Println(i)\n\t\t\t\t\tfmt.Println(stre[j][1])\n\t\t\t\t\toutput += stra[i]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput += stra[i]\n\t\t\t}\n\t\t}\n\t\toutputb := []byte(output)\n\t\tioutil.WriteFile(input, outputb, 0755)\n\t}\n}\n","03-expert - gracefulstoppablehttpd":"package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net\/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar listener net.Listener\nvar requestcounter int\nvar stopvar bool\n\ntype handler struct {\n\twg sync.WaitGroup\n\t*http.ServeMux\n}\n\nfunc (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.wg.Add(1)\n\tdefer h.wg.Done()\n\th.ServeMux.ServeHTTP(w, r)\n\n\tw.(http.Flusher).Flush()\n}\n\nfunc restart(w http.ResponseWriter, r *http.Request) {\n\tlistener.Close()\n\tw.Write([]byte(\"listener restarted\"))\n}\n\nfunc stop(w http.ResponseWriter, r *http.Request) {\n\tstopvar = true\n\tlistener.Close()\n\tw.Write([]byte(\"listener stoped\"))\n}\n\nfunc normal(w http.ResponseWriter, r *http.Request) {\n\turl := r.URL.Path\n\tif r.URL.RawQuery != \"\" {\n\t\turl = strings.Join([]string{url, \"?\", r.URL.RawQuery}, \"\")\n\t}\n\tfmt.Fprintf(w, \"Hello World\\nYou requested: %s\\n\", url)\n\ttime.Sleep(4 * time.Second)\n\tfmt.Fprintf(w, \"this is request number %s\\n\", strconv.Itoa(requestcounter))\n\tlog.Println(url)\n\trequestcounter++\n}\n\nfunc main() {\n\tlog.Printf(\"started program\")\n\tvar err error\n\tvar ler string\n\tfor !stopvar {\n\t\tlistener, err = net.Listen(\"tcp\", \":8080\")\n\n\t\tif err == nil {\n\t\t\tlog.Printf(\"started listener on port 8080 with counter: %v\\n\", requestcounter)\n\t\t\th := &handler{ServeMux: http.NewServeMux()}\n\n\t\t\th.ServeMux.HandleFunc(\"\/\", normal)\n\t\t\th.ServeMux.HandleFunc(\"\/stop\", stop)\n\t\t\th.ServeMux.HandleFunc(\"\/restart\", restart)\n\n\t\t\thttp.Serve(listener, h)\n\n\t\t\th.wg.Wait()\n\t\t} else {\n\t\t\tif fmt.Sprintf(\"%v\", err) != ler {\n\t\t\t\tler = fmt.Sprintf(\"%v\", err)\n\t\t\t\tfmt.Println(ler)\n\t\t\t}\n\t\t}\n\t}\n}\n","03-expert - httpd":"package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar requestcounter int\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\turl := r.URL.Path\n\tif r.URL.RawQuery != \"\" {\n\t\turl = strings.Join([]string{url, \"?\", r.URL.RawQuery}, \"\")\n\t}\n\tfmt.Fprintf(w, \"Hello World\\nYou requested: %s\\n\", url)\n\tfmt.Fprintf(w, \"this is request number %s\\n\", strconv.Itoa(requestcounter))\n\tlog.Println(url)\n\trequestcounter++\n}\n\nfunc main() {\n\thttp.HandleFunc(\"\/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}\n","03-expert - httpsd":"package main\n\nimport (\n\t\"crypto\/rand\"\n\t\"crypto\/rsa\"\n\t\"crypto\/tls\"\n\t\"crypto\/x509\"\n\t\"crypto\/x509\/pkix\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"log\"\n\t\"math\/big\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n)\n\nvar pem string\nvar key string\n\nfunc genCert() {\n\tca := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1337),\n\t\tSubject: pkix.Name{\n\t\t\tCountry:            []string{\"Neuland\"},\n\t\t\tOrganization:       []string{\"qwertz\"},\n\t\t\tOrganizationalUnit: []string{\"qwertz\"},\n\t\t},\n\t\tIssuer: pkix.Name{\n\t\t\tCountry:            []string{\"Neuland\"},\n\t\t\tOrganization:       []string{\"Skynet\"},\n\t\t\tOrganizationalUnit: []string{\"Computer Emergency Response Team\"},\n\t\t\tLocality:           []string{\"Neuland\"},\n\t\t\tProvince:           []string{\"Neuland\"},\n\t\t\tStreetAddress:      []string{\"Mainstreet 23\"},\n\t\t\tPostalCode:         []string{\"12345\"},\n\t\t\tSerialNumber:       \"23\",\n\t\t\tCommonName:         \"23\",\n\t\t},\n\t\tSignatureAlgorithm:    x509.SHA512WithRSA,\n\t\tPublicKeyAlgorithm:    x509.ECDSA,\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(0, 0, 10),\n\t\tSubjectKeyId:          []byte{1, 2, 3, 4, 5},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t}\n\n\tpriv, _ := rsa.GenerateKey(rand.Reader, 4096)\n\tpub := &priv.PublicKey\n\tca_b, err := x509.CreateCertificate(rand.Reader, ca, ca, pub, priv)\n\tif err != nil {\n\t\tlog.Fatalf(\"create cert failed %#v\", err)\n\t\treturn\n\t}\n\tlog.Println(\"save\", pem)\n\tioutil.WriteFile(pem, ca_b, 0644)\n\tlog.Println(\"save\", key)\n\tioutil.WriteFile(key, x509.MarshalPKCS1PrivateKey(priv), 0644)\n}\n\nfunc handleClient(conn net.Conn) {\n\tdefer conn.Close()\n\tbuf := make([]byte, 512)\n\tlog.Print(\"https: waiting\")\n\tcon, err := conn.Read(buf)\n\tif err != nil {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"https: read: %#v\", err)\n\t\t}\n\t}\n\n\tlog.Printf(\"https: echo %q\\n\", string(buf[:con]))\n\n\tconn.Write([]byte(time.Now().Format(time.RFC3339) + \"\\r\\n\\n\"))\n\tcon, err = conn.Write(buf[:con])\n\tlog.Printf(\"https: wrote %d bytes\", con)\n\n\tif err != nil {\n\t\tlog.Printf(\"https: write: %s\", err)\n\t}\n\tlog.Println(\"https: closed\")\n}\n\nfunc main() {\n\tpem = \"cert.pem\"\n\tkey = \"cert.key\"\n\tif _, err := os.Stat(pem); os.IsNotExist(err) {\n\t\tif _, err := os.Stat(key); os.IsNotExist(err) {\n\t\t\tfmt.Println(\"no certs found, generating new self signed certs.\")\n\t\t\tgenCert()\n\t\t}\n\t}\n\tif _, err := os.Stat(key); err == nil {\n\t\tca_b, _ := ioutil.ReadFile(pem)\n\t\tca, _ := x509.ParseCertificate(ca_b)\n\t\tpriv_b, _ := ioutil.ReadFile(key)\n\t\tpriv, _ := x509.ParsePKCS1PrivateKey(priv_b)\n\t\tpool := x509.NewCertPool()\n\t\tpool.AddCert(ca)\n\n\t\tcert := tls.Certificate{\n\t\t\tCertificate: [][]byte{ca_b},\n\t\t\tPrivateKey:  priv,\n\t\t}\n\n\t\tconfig := tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\t\/\/MinVersion:   tls.VersionSSL30, \/\/don't use SSLv3, https:\/\/www.openssl.org\/~bodo\/ssl-poodle.pdf\n\t\t\tMinVersion: tls.VersionTLS10,\n\t\t\t\/\/MinVersion:   tls.VersionTLS11,\n\t\t\t\/\/MinVersion:   tls.VersionTLS12,\n\t\t}\n\t\tconfig.Rand = rand.Reader\n\t\tport := \":4443\"\n\t\tlistener, err := tls.Listen(\"tcp\", port, &config)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"https: listen: %s\", err)\n\t\t}\n\t\tlog.Printf(\"https: listening on %s\", port)\n\n\t\tfor {\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"https: accept: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefer conn.Close()\n\t\t\tlog.Printf(\"https: accepted from %s to %s\", conn.RemoteAddr(), port)\n\t\t\tgo handleClient(conn)\n\t\t}\n\t} else {\n\t\tlog.Fatalf(\"https: NO CERT FOUND\")\n\t}\n}\n","03-expert - image":"package main\n\nimport (\n\t\"fmt\"\n\t\"image\/color\"\n\t\"image\/png\"\n\t\"log\"\n\t\"os\"\n)\n\ntype ImageSet interface {\n\tSet(x, y int, c color.Color)\n}\n\nfunc main() {\n\tfile, err := os.Open(\".\/images\/selfcss.png\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\timg, err := png.Decode(file)\n\tif err != nil {\n\t\tlog.Fatal(os.Stderr, \"%s: %v\\n\", \".\/images\/selfcss.png\", err)\n\t}\n\n\tb := img.Bounds()\n\n\timgSet := img.(ImageSet)\n\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n\t\t\toldPixel := img.At(x, y)\n\t\t\tr, g, b, a := oldPixel.RGBA()\n\t\t\tfmt.Println(r, g, b, a)\n\t\t\tpixel := color.RGBA{uint8(g), uint8(g), uint8(g), uint8(a)}\n\t\t\timgSet.Set(x, y, pixel)\n\t\t}\n\t}\n\n\tfd, err := os.Create(\".\/images\/gray.png\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = png.Encode(fd, img)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = fd.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfile, err = os.Open(\".\/images\/selfcss.png\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\timg, err = png.Decode(file)\n\tif err != nil {\n\t\tlog.Fatal(os.Stderr, \"%s: %v\\n\", \".\/images\/selfcss.png\", err)\n\t}\n\n\tb = img.Bounds()\n\n\timgSet = img.(ImageSet)\n\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n\t\t\toldPixel := img.At(x, y)\n\t\t\tr, g, b, a := oldPixel.RGBA()\n\t\t\t\/\/fmt.Println(r, g, b, a)\n\t\t\tr = 65535 - r\n\t\t\tg = 65535 - g\n\t\t\tb = 65535 - b\n\t\t\tpixel := color.RGBA{uint8(r), uint8(g), uint8(b), uint8(a)}\n\t\t\timgSet.Set(x, y, pixel)\n\t\t}\n\t}\n\n\tfd, err = os.Create(\".\/images\/inv.png\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = png.Encode(fd, img)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = fd.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n","03-expert - image2":"package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image\/color\"\n\t\"image\/png\"\n\t\"math\"\n\t\"os\"\n)\n\ntype Circle struct {\n\tX, Y, Radius float64\n}\n\nfunc (c *Circle) Brightness(x, y float64) uint8 {\n\tvar dx, dy float64 = c.X - x, c.Y - y\n\td := math.Sqrt(dx*dx+dy*dy) \/ c.Radius\n\tif d > 1 {\n\t\treturn 0\n\t} else {\n\t\treturn uint8((1 - math.Pow(d, 12)) * 255)\n\t}\n}\n\nfunc main() {\n\tvar width, height int = 300, 300\n\tvar hwidth, hheight float64 = float64(width \/ 2), float64(height \/ 2)\n\tvar radius float64 = 42\n\n\tp := 2 * math.Pi \/ 3\n\tcircleRed := &Circle{hwidth - radius*math.Sin(0), hheight - radius*math.Cos(0), 60}\n\tcircleGreen := &Circle{hwidth - radius*math.Sin(p), hheight - radius*math.Cos(p), 60}\n\tcircleBlue := &Circle{hwidth - radius*math.Sin(-p), hheight - radius*math.Cos(-p), 60}\n\n\tm := image.NewRGBA(image.Rect(0, 0, width, height))\n\tfor x := 0; x < width; x++ {\n\t\tfor y := 0; y < height; y++ {\n\t\t\tcol := color.RGBA{\n\t\t\t\tcircleRed.Brightness(float64(x), float64(y)),\n\t\t\t\tcircleGreen.Brightness(float64(x), float64(y)),\n\t\t\t\tcircleBlue.Brightness(float64(x), float64(y)),\n\t\t\t\t255,\n\t\t\t}\n\t\t\tm.Set(x, y, col)\n\t\t}\n\t}\n\n\tf, err := os.OpenFile(\".\/images\/rgb.png\", os.O_WRONLY|os.O_CREATE, 0600)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\tpng.Encode(f, m)\n}\n","03-expert - image3":"\/\/ based on https:\/\/github.com\/SimonWaldherr\/bbmandelbrotGo\npackage main\n\nimport (\n\t\"image\"\n\t\"image\/color\"\n\t\"image\/png\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\t\"sync\"\n)\n\nconst (\n\tmaxiteration = 192\n)\n\nvar (\n\tzh float64\n\tzv float64\n)\n\nfunc init() {\n\tzh = 2.4\n\tzv = 2.4\n}\n\nfunc abs(z complex128) float64 {\n\treturn math.Hypot(real(z), imag(z))\n}\n\nfunc mandel(c complex128) float64 {\n\tz := complex128(0)\n\tfor i := 0; i < maxiteration; i++ {\n\t\tif abs(z) > 2 {\n\t\t\treturn float64(i-1) \/ maxiteration\n\t\t}\n\t\tz = z*z + c\n\t}\n\treturn 0\n}\n\nfunc pixelColor(x, y, width, height uint64, csr, csg, csb int) color.RGBA {\n\txf := float64(x)\/float64(width)*zv - (zv\/2.0 + 0.5)\n\tyf := float64(y)\/float64(height)*zh - (zh \/ 2.0)\n\tc := complex(xf, yf)\n\tcalcval := int(mandel(c) * 255)\n\n\treturn color.RGBA{\n\t\tuint8(int(csr) * calcval % 255),\n\t\tuint8(int(csg) * calcval % 255),\n\t\tuint8(int(csb) * calcval % 255),\n\t\t255,\n\t}\n}\n\n\/\/ Mandelbrot generates the Mandelbrot picture as *image.RGBA according to the parameters\nfunc Mandelbrot(width, height, cx1, cx2, cy1, cy2 uint64, csr, csg, csb int) (*image.RGBA, string) {\n\tvar wg sync.WaitGroup\n\tvar fullHeight bool\n\n\tbackground := image.Rect(0, 0, int(cx2-cx1), int(cy2-cy1))\n\timg := image.NewRGBA(background)\n\n\tif height == cy2 && cy1 == 0 {\n\t\tfullHeight = true\n\t\tcy2 = cy2 \/ 2\n\t}\n\n\tfor x := cx1; x < cx2; x++ {\n\t\twg.Add(1)\n\t\tgo func(x uint64) {\n\t\t\tdefer wg.Done()\n\t\t\tif fullHeight {\n\t\t\t\tfor y := cy1; y < cy2+1; y++ {\n\t\t\t\t\tcolval := pixelColor(x, y, width, height, csr, csg, csb)\n\t\t\t\t\timg.Set(int(x)-int(cx1), int(y), colval)\n\t\t\t\t\timg.Set(int(x)-int(cx1), int(height)-int(y), colval)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor y := cy1; y < cy2; y++ {\n\t\t\t\t\tcolval := pixelColor(x, y, width, height, csr, csg, csb)\n\t\t\t\t\timg.Set(int(x)-int(cx1), int(y)-int(cy1), colval)\n\t\t\t\t}\n\t\t\t}\n\t\t}(x)\n\t}\n\n\twg.Wait()\n\n\treturn img, \"\"\n}\n\nfunc main() {\n\timg, _ := Mandelbrot(900, 900, 0, 900, 0, 900, 2, 3, 1)\n\n\tfile, err := os.OpenFile(\".\/images\/mandelbrot.png\", os.O_WRONLY|os.O_CREATE, 0600)\n\tdefer file.Close()\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening file: %s\\n\", err)\n\t}\n\n\terr = png.Encode(file, img)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error encoding image: %s\\n\", err)\n\t}\n}\n","03-expert - label":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc BreakExample() {\n\tfmt.Println(\"\\n\\nBreak Example\")\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Print(\"\\ni:\", i)\n\t\tif i > 5 {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Print(\".\")\n\t}\n}\n\nfunc ContinueExample() {\n\tfmt.Println(\"\\n\\nContinue Example\")\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Print(\"\\ni:\", i)\n\t\tif i > 5 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Print(\".\")\n\t}\n}\n\nfunc ContinueToLabelExample() {\n\tvar i, j int\n\tfmt.Println(\"\\n\\nContinue to Label Example\")\nOUT:\n\tfor i = 0; i < 10; i++ {\n\t\tfor j = 0; j < 10; j++ {\n\t\t\tfmt.Print(\"\\ni:\", i, \"j:\", j)\n\t\t\tif i > 2 && j > 2 {\n\t\t\t\tcontinue OUT\n\t\t\t}\n\t\t\tfmt.Print(\".\")\n\t\t}\n\t}\n\n\tfmt.Println(\"i:\", i, \"j:\", j)\n}\n\nfunc GotoExample() {\n\tfmt.Println(\"\\n\\nGoto Example\")\n\tvar i = 0\n\nSTART:\n\ti++\n\tfmt.Println(\"i:\", i)\n\tif i < 10 {\n\t\tgoto START\n\t}\n\n\tfmt.Println(\"finish\")\n}\n\nfunc GotoExample2() {\n\tfmt.Println(\"\\n\\nGoto Example 2\")\n\tvar i = 0\n\nSTART:\n\ti++\n\tfmt.Println(\"i:\", i)\n\tif i < 10 {\n\t\tgoto START\n\t} else {\n\t\tgoto END\n\t}\n\n\tfmt.Println(\"never print this!!!\")\n\nEND:\n}\n\nfunc main() {\n\tBreakExample()\n\tContinueExample()\n\tContinueToLabelExample()\n\tGotoExample()\n\tGotoExample2()\n}\n","03-expert - parallel":"package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nvar (\n\t\/\/ list of nth prime numbers to find\n\trequests = []int{200000, 500000, 100000, 250000, 550000, 150000, 350000, 300000}\n)\n\nfunc main() {\n\tif len(os.Args) == 1 {\n\t\tfmt.Println(\"start this application with the argument true to compute primenumbers parallel or false for serial\")\n\t\tfmt.Println(\"you can configure the maximum processes\/threads amount with: \\\"export GOMAXPROCS=$number\\\"\")\n\t\tos.Exit(1)\n\t}\n\n\tif os.Args[1] == \"true\" {\n\t\trunParallel()\n\t} else {\n\t\trunSequential()\n\t}\n}\n\nfunc runSequential() {\n\tfor _, index := range requests {\n\t\tfmt.Printf(\"the %dth prime number is: %d\\n\", index, getPrime(index))\n\t}\n}\n\nfunc runParallel() {\n\t\/\/ data struct that goroutines will send information\n\t\/\/ back to main thread\n\ttype WorkerResponse struct {\n\t\tIndex int\n\t\tPrime int\n\t}\n\n\tworkerChan := make(chan WorkerResponse)\n\tdefer close(workerChan)\n\n\t\/\/ send requests to n goroutines\n\tfor _, index := range requests {\n\t\t\/\/ start this goroutine with the index in the loop\n\t\t\/\/ we must give this param, because index would be shared memory\n\t\tgo func(idx int) {\n\t\t\tworkerChan <- WorkerResponse{Index: idx, Prime: getPrime(idx)}\n\t\t}(index)\n\t}\n\n\tfor i := 0; i < len(requests); i++ {\n\t\tresponse := <-workerChan\n\t\tfmt.Printf(\"the %dth prime number is: %d\\n\", response.Index, response.Prime)\n\t}\n}\n\nfunc Sqrt(n int) int {\n\tvar t uint\n\tvar b uint\n\tvar r uint\n\tt = uint(n)\n\tp := uint(1 << 30)\n\tfor p > t {\n\t\tp >>= 2\n\t}\n\tfor ; p != 0; p >>= 2 {\n\t\tb = r | p\n\t\tr >>= 1\n\t\tif t >= b {\n\t\t\tt -= b\n\t\t\tr |= p\n\t\t}\n\t}\n\treturn int(r)\n}\n\nfunc getPrime(n int) int {\n\tvar primeList = []int{2}\n\tvar isPrime int = 1\n\tvar num int = 3\n\tvar sqrtNum int = 0\n\tfor len(primeList) < n {\n\t\tsqrtNum = Sqrt(num)\n\t\tfor i := 0; i < len(primeList); i++ {\n\t\t\tif num%primeList[i] == 0 {\n\t\t\t\tisPrime = 0\n\t\t\t}\n\t\t\tif primeList[i] > sqrtNum {\n\t\t\t\ti = len(primeList)\n\t\t\t}\n\t\t}\n\t\tif isPrime == 1 {\n\t\t\tprimeList = append(primeList, num)\n\t\t} else {\n\t\t\tisPrime = 1\n\t\t}\n\t\tnum = num + 2\n\t}\n\treturn primeList[n-1]\n}\n","03-expert - ppk-crypto":"package main\n\nimport (\n\t\"crypto\/ecdsa\"\n\t\"crypto\/elliptic\"\n\t\"crypto\/rand\"\n\t\"crypto\/x509\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\/big\"\n\t\"os\"\n)\n\nfunc genPPKeys(random io.Reader) (private_key_bytes, public_key_bytes []byte) {\n\tprivate_key, _ := ecdsa.GenerateKey(elliptic.P224(), random)\n\tprivate_key_bytes, _ = x509.MarshalECPrivateKey(private_key)\n\tpublic_key_bytes, _ = x509.MarshalPKIXPublicKey(&private_key.PublicKey)\n\treturn private_key_bytes, public_key_bytes\n}\n\nfunc pkSign(hash []byte, private_key_bytes []byte) (r, s *big.Int, err error) {\n\tzero := big.NewInt(0)\n\tprivate_key, err := x509.ParseECPrivateKey(private_key_bytes)\n\tif err != nil {\n\t\treturn zero, zero, err\n\t}\n\n\tr, s, err = ecdsa.Sign(rand.Reader, private_key, hash)\n\tif err != nil {\n\t\treturn zero, zero, err\n\t}\n\treturn r, s, nil\n}\n\nfunc pkVerify(hash []byte, public_key_bytes []byte, r *big.Int, s *big.Int) (result bool) {\n\tpublic_key, err := x509.ParsePKIXPublicKey(public_key_bytes)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tswitch public_key := public_key.(type) {\n\tcase *ecdsa.PublicKey:\n\t\treturn ecdsa.Verify(public_key, hash, r, s)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc main() {\n\tvar str []byte\n\tif len(os.Args) > 1 {\n\t\tstr = []byte(os.Args[1])\n\t} else {\n\t\tstr = []byte(\"Lorem Ipsum dolor sit Amet\")\n\t}\n\n\tprivate_key, public_key := genPPKeys(rand.Reader)\n\tfmt.Print(\"private key: \")\n\tfmt.Println(private_key)\n\tfmt.Println()\n\tfmt.Print(\"public key: \")\n\tfmt.Println(public_key)\n\tfmt.Println()\n\n\tr, s, err := pkSign(str, private_key)\n\tif err != nil {\n\t\tfmt.Printf(\"signing hash error: %s\\n\", err)\n\t}\n\n\tverify := pkVerify(str, public_key, r, s)\n\tfmt.Printf(\"signature verification result: %t\\n\", verify)\n\n\tverify = pkVerify([]byte(\"some other text\"), public_key, r, s)\n\tfmt.Printf(\"signature verification result: %t\\n\", verify)\n}\n","03-expert - proxy":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"log\"\n\t\"net\/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nvar url string\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\turl = strings.Join([]string{\"http:\/\/\", \"blog.fefe.de\", r.URL.Path}, \"\")\n\tif r.URL.RawQuery != \"\" {\n\t\turl = strings.Join([]string{url, \"?\", r.URL.RawQuery}, \"\")\n\t}\n\tresponse, err := http.Get(url)\n\tif err != nil {\n\t\tos.Exit(2)\n\t} else {\n\t\tdefer response.Body.Close()\n\t\tcontents, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"%s\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Fprintf(w, string(contents))\n\t\tlog.Println(url)\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"\/\", handler)\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}\n","03-expert - stringdistance":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc invBool2int(b bool) int {\n\tif !b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc LevenshteinDistance(a, b string) int {\n\tlen1, len2 := len(a), len(b)\n\tif len1 < len2 {\n\t\treturn LevenshteinDistance(b, a)\n\t}\n\trow1, row2 := make([]int, len2+1), make([]int, len2+1)\n\n\tfor i := 0; i < len2+1; i++ {\n\t\trow2[i] = i\n\t}\n\n\tfor i := 0; i < len1; i++ {\n\t\trow1[0] = i + 1\n\n\t\tfor j := 0; j < len2; j++ {\n\t\t\tx := min(row2[j+1]+1, row1[j]+1)\n\t\t\ty := row2[j] + invBool2int(a[i] == b[j])\n\t\t\trow1[j+1] = min(x, y)\n\t\t}\n\n\t\trow1, row2 = row2, row1\n\t}\n\treturn row2[len2]\n}\n\nfunc DamerauLevenshteinDistance(a, b string) int {\n\tlen1, len2 := len(a), len(b)\n\tif len1 == 0 {\n\t\treturn len2\n\t}\n\tif len2 == 0 {\n\t\treturn len1\n\t}\n\tif len1 < len2 {\n\t\treturn DamerauLevenshteinDistance(b, a)\n\t}\n\tcurr, next := 0, 0\n\trow := make([]int, len2+1)\n\n\tfor i := 0; i < len2+1; i++ {\n\t\trow[i] = i\n\t}\n\n\tfor i := 0; i < len1; i++ {\n\t\tcurr = i + 1\n\n\t\tfor j := 0; j < len2; j++ {\n\t\t\tcost := invBool2int(a[i] == b[j] || (i > 0 && j > 0 && a[i-1] == b[j] && a[i] == b[j-1]))\n\n\t\t\tnext = min(min(\n\t\t\t\trow[j+1]+1,\n\t\t\t\trow[j]+cost),\n\t\t\t\tcurr+1)\n\n\t\t\trow[j], curr = curr, next\n\t\t}\n\t\trow[len2] = next\n\t}\n\treturn next\n}\n\nfunc main() {\n\tfmt.Printf(\"LevenshteinDistance(\\\"foobar\\\", \\\"fubar\\\"): %v\\n\", LevenshteinDistance(\"foobar\", \"fubar\"))\n\tfmt.Printf(\"DamerauLevenshteinDistance(\\\"foobar\\\", \\\"fubar\\\"): %v\\n\", DamerauLevenshteinDistance(\"foobar\", \"fubar\"))\n}\n","03-expert - tcp":"package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\nconst retrytime = 510 * time.Millisecond\n\nfunc tcpClient(str, addr string) string {\n\treturn tcpClientHelper(str, addr, 3)\n}\n\nfunc tcpClientHelper(str, addr string, retry int) string {\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp\", addr)\n\tconn, err := net.DialTCP(\"tcp4\", nil, tcpAddr)\n\tif err == nil {\n\t\tdefer conn.Close()\n\n\t\tpayloadBytes := []byte(fmt.Sprintf(\"%s\\r\\n\\r\\n\", str))\n\t\tif _, err = conn.Write(payloadBytes); err != nil {\n\t\t\tlog.Println(err)\n\n\t\t\tif retry > 0 {\n\t\t\t\ttime.Sleep(retrytime)\n\t\t\t\treturn tcpClientHelper(str, addr, retry-1)\n\t\t\t}\n\t\t}\n\t\tbytes := make([]byte, 65535)\n\t\t_, err := bufio.NewReader(conn).Read(bytes)\n\t\tif err == nil || err == io.EOF {\n\t\t\treturn string(bytes)\n\t\t}\n\t\treturn fmt.Sprint(err)\n\t}\n\tlog.Println(err)\n\n\tif retry > 0 {\n\t\ttime.Sleep(retrytime)\n\t\treturn tcpClientHelper(str, addr, retry-1)\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\tvar host string = \"google.de\"\n\tvar port string = \"80\"\n\tvar request string = \"GET \/index.html\"\n\n\tresponse := tcpClient(request, host+\":\"+port)\n\tfmt.Printf(\"response from %v:%v for the request \\\"%v\\\" is: \\n%v\\n\", host, port, request, response)\n}\n","03-expert - telnet":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc handleConnection(c net.Conn, msgchan chan<- string) {\n\tdefer c.Close()\n\tfmt.Printf(\"Connection from %v established.\\n\", c.RemoteAddr())\n\tc.SetReadDeadline(time.Now().Add(time.Second * 5))\n\tbuf := make([]byte, 4096)\n\tfor {\n\t\tn, err := c.Read(buf)\n\t\tif (err != nil) || (n == 0) {\n\t\t\tc.Close()\n\t\t\tbreak\n\t\t}\n\t\tmsgchan <- string(buf[0:n])\n\t}\n\ttime.Sleep(150 * time.Millisecond)\n\tfmt.Printf(\"Connection from %v closed.\\n\", c.RemoteAddr())\n\tc.Close()\n\treturn\n}\n\nfunc printMessages(msgchan <-chan string) {\n\tvar count int = 0\n\tfor {\n\t\tmsg := strings.TrimSpace(<-msgchan)\n\t\tcount++\n\t\tfmt.Printf(\"Data %d: %s\\n\", count, msg)\n\t}\n}\n\nfunc main() {\n\tflag.Parse()\n\tport := \":\" + flag.Arg(0)\n\tif port == \":\" {\n\t\tport = \":2223\"\n\t}\n\tln, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tmsgchan := make(chan string)\n\tgo printMessages(msgchan)\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn, msgchan)\n\t}\n}\n","03-expert - upload":"package main\n\nimport (\n\t\"fmt\"\n\t\"html\/template\"\n\t\"io\/ioutil\"\n\t\"net\/http\"\n\t\"os\"\n)\n\nvar size int64 = 5 * 1024 * 1024\nvar html = template.Must(template.New(\"html\").Parse(`\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\"\/>\n\t\t<title>Golang File Upload<\/title>\n\t<\/head>\n\t<body>\n\t\t<form action=\"\/upload\" method=\"POST\" enctype=\"multipart\/form-data\">\n\t\t\t<label for=\"file\">File: <\/label>\n\t\t\t<input name=\"file\" type=\"file\"><\/input>\n\t\t\t<button type=\"submit\">upload<\/button>\n\t\t<\/form>\n\t<\/body>\n<\/html>\n`))\n\nfunc root(w http.ResponseWriter, r *http.Request) {\n\terr := html.Execute(w, nil)\n\tif err != nil {\n\t\tfmt.Print(err)\n\t}\n}\n\nfunc upload(w http.ResponseWriter, r *http.Request) {\n\tvar path string\n\tif err := r.ParseMultipartForm(size); err != nil {\n\t\tfmt.Println(err)\n\t\thttp.Error(w, err.Error(), http.StatusForbidden)\n\t}\n\n\tfor _, fileHeaders := range r.MultipartForm.File {\n\t\tfor _, fileHeader := range fileHeaders {\n\t\t\tfile, _ := fileHeader.Open()\n\t\t\tpath = fmt.Sprintf(\"%s\", fileHeader.Filename)\n\t\t\tbuf, _ := ioutil.ReadAll(file)\n\t\t\tioutil.WriteFile(path, buf, os.ModePerm)\n\t\t}\n\t}\n\tfmt.Printf(\"File \\\"%v\\\" uploaded\\n\", path)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"\/upload\", upload)\n\thttp.HandleFunc(\"\/\", root)\n\tfmt.Print(http.ListenAndServe(\":8080\", nil))\n}\n"};
